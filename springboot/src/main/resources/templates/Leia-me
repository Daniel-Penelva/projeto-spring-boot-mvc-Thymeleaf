Acessar a aplicação: 
http://localhost:8080/
http://localhost:8080/cadastropessoa
   
   < ARQUITETURA MVC - FUNCIONAMENTO > 
                                  
                                                                                                   |-----------------------------------------------
 Tela/ Cliente/ Sistema                                                                            |         JAVA/ SPRING MVC/ SERVLET            |
    _______                                                                                        |                                              |
   |       |                                                                                       |                                              |
   |       |                requisição /POST/GET                                                   |   CONTROLLER                BANCO DE DADOS   |
   |       | ------------------------------------------------------------------------------------->| |------------|              |------------|   |
   |       |                                                                                       | | validações |              |    dados   |   |
   |       | RESPOSTA compilada com o HTML para o navegador interpretar                            | |            |              |            |   |
   |_______| <-------------------------------------------------------------------------------------| |____________|              |____________|   |
                                                                                                   |                                              |
   Front-End                                                                                       |    ^    |                      ^      |      |
    (HTML)                                                                                         |    |    |                      |      |      |
  (Javascript)                                                                                     |    |    v                      |      v      |
                                                                                                   |                                              |
                                                                                                   |   SERVICE                    DAO/REPOSITORY  |
                                                                                                   | |----------|                 |-----------|   |
                                                                                                   | | Regra de | --------------> | SQL/JPA   |   |
                                                                                                   | | negócio  | <-------------- |           |   |
                                                                                                   | |__________|                 |___________|   |
                                                                                                   |______________________________________________|

A arquitetura MVC (Model-View-Controller) é um padrão de arquitetura de software amplamente utilizado para o desenvolvimento de aplicativos. Ele separa a lógica de 
negócios, a apresentação dos dados e a interação com o usuário em três componentes distintos: Model, View e Controller. Cada componente possui responsabilidades 
específicas e se comunica com os outros componentes de forma estruturada. Vamos entender como cada componente funciona:

1. Model:
O Model representa a camada de dados e lógica de negócios. Ele encapsula o estado e o comportamento dos dados da aplicação. Essa camada é responsável por acessar e 
manipular os dados, bem como aplicar as regras de negócio. O Model geralmente consiste em classes como entidades, serviços, repositórios, APIs, etc.

2. View:
A View é responsável pela apresentação dos dados ao usuário. Ela exibe a interface do usuário, como páginas HTML, telas, formulários, gráficos, entre outros elementos 
visuais. A View recebe dados do Model para exibi-los e também envia informações do usuário para o Controller. Geralmente, as Views são implementadas usando tecnologias 
como HTML, CSS, JavaScript, JSP, Thymeleaf, entre outras.

3. Controller:
O Controller é responsável por receber as requisições do usuário, processá-las e coordenar as ações apropriadas. Ele atua como intermediário entre a View e o Model. 
O Controller é responsável por receber os dados da View, interagir com o Model para executar ações necessárias, como buscar dados, atualizar informações, executar 
lógica de negócio, etc., e então retornar os resultados para a View. Normalmente, os Controllers são implementados como classes ou métodos em frameworks web, como 
Spring MVC, ASP.NET MVC, Django, entre outros.

No contexto da arquitetura MVC, o Service (ou Service Layer) é responsável por abrigar a lógica de negócio da aplicação. Ele atua como uma camada intermediária entre 
o Controller e o Model, encapsulando as regras e operações complexas relacionadas ao domínio do problema. O Service é uma prática comum em muitas implementações de MVC
e tem como objetivo principal separar a lógica de negócio do Controller e do Model, mantendo assim a responsabilidade de cada camada de forma clara e modular.

No contexto da arquitetura MVC, o DAO (Data Access Object) ou Repository é responsável por encapsular a interação com o banco de dados e fornecer métodos para realizar 
operações de persistência e recuperação de dados. O DAO/Repository atua como uma camada de abstração entre o Model e o banco de dados, permitindo que o restante da 
aplicação trabalhe com objetos do Model sem se preocupar com detalhes específicos de acesso aos dados. Em resumo, o DAO/Repository na estrutura MVC é responsável por 
encapsular a lógica de acesso aos dados do banco de dados, fornecendo métodos para realizar operações de persistência e recuperação de dados. Ele abstrai os detalhes 
de acesso ao banco de dados, permite consultas customizadas e promove a testabilidade das operações de dados.

O fluxo básico de funcionamento da arquitetura MVC é o seguinte:

1. O usuário interage com a View, como preenchendo um formulário ou clicando em um botão.
2. A View captura as interações do usuário e envia uma requisição para o Controller correspondente.
3. O Controller recebe a requisição, processa-a e interage com o Model, se necessário, para executar as ações apropriadas.
4. O Model executa as operações de manipulação de dados e lógica de negócio necessárias.
5. O Controller recebe os resultados do Model e seleciona a View adequada para renderizar os dados.
6. A View recebe os dados do Controller e os apresenta ao usuário de forma adequada.
7. O usuário visualiza os resultados na View e, se necessário, inicia uma nova interação.

Essa separação de responsabilidades facilita a manutenção, a reutilização de código e o desenvolvimento colaborativo, uma vez que cada componente possui uma função 
claramente definida. Além disso, a arquitetura MVC permite uma maior flexibilidade, pois é possível alterar a View ou o Model independentemente um do outro, desde que 
a interface entre eles seja mantida.

Vale ressaltar que existem variações e adaptações do padrão MVC, como o MVVM (Model-View-ViewModel) e o MVP (Model-View-Presenter), que incorporam diferentes abordagens 
para atender a necessidades específicas de diferentes frameworks e tecnologias. No entanto, a ideia fundamental de separação de responsabilidades entre Model, View e 
Controller permanece como base em várias arquiteturas de software.

--------------------------------------------------------------------------------------------------- // --------------------------------------------------------------------------

Bom Saber:

A propriedade "spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults" é uma configuração específica do Hibernate, um framework de mapeamento objeto-relacional para Java, 
quando usado em conjunto com o Spring Framework.

Essa propriedade determina se o Hibernate deve usar os metadados padrão do JDBC (Java Database Connectivity) ao criar tabelas temporárias durante a execução de consultas. Quando 
definida como "false", o Hibernate irá desabilitar o uso dos metadados padrão do JDBC e, em vez disso, irá usar seus próprios metadados para a criação das tabelas temporárias.

Essa configuração pode ser útil em certos casos em que o comportamento padrão do Hibernate com relação às tabelas temporárias não atende aos requisitos específicos do aplicativo. 
Ao desabilitar o uso dos metadados padrão do JDBC, você pode ter um controle mais preciso sobre a criação e configuração dessas tabelas temporárias.

É importante destacar que essa é apenas uma das várias propriedades de configuração disponíveis no Hibernate e no Spring Framework, e seu efeito exato dependerá do contexto em 
que está sendo utilizada, assim como das outras configurações do aplicativo. Recomenda-se consultar a documentação oficial do Hibernate e do Spring Framework para obter informações 
mais detalhadas sobre o uso dessa propriedade e outras configurações relacionadas.

------------- // -------------

A propriedade "spring.jpa.properties.hibernate.dialect" é utilizada para configurar o dialeto (dialect) do Hibernate ao trabalhar com um banco de dados específico. Neste caso em 
particular, o valor definido para a propriedade é "org.hibernate.dialect.PostgreSQLDialect", indicando que o Hibernate deve utilizar o dialeto do PostgreSQL.

O dialeto do Hibernate é responsável por fornecer as instruções SQL específicas do banco de dados que estão sendo utilizadas. Cada banco de dados possui suas próprias particularidades 
e diferenças na sintaxe e recursos SQL. Portanto, é necessário configurar corretamente o dialeto do Hibernate para que ele possa gerar as consultas SQL adequadas e compatíveis 
com o banco de dados em uso.

Ao definir "org.hibernate.dialect.PostgreSQLDialect" como o valor dessa propriedade, o Hibernate irá gerar as consultas SQL específicas para o PostgreSQL. O dialeto do PostgreSQL 
é otimizado para trabalhar com esse banco de dados em particular, aproveitando os recursos e as funcionalidades específicas oferecidas pelo PostgreSQL.

É importante observar que o Hibernate oferece uma variedade de dialetos para diferentes bancos de dados, e a escolha correta do dialeto a ser usado depende do banco de dados que 
está sendo utilizado em sua aplicação. Se você estiver usando um banco de dados diferente do PostgreSQL, será necessário fornecer o dialeto apropriado correspondente ao seu banco 
de dados específico.

------------- // -------------

A anotação `@ComponentScan` é uma anotação do Spring Framework que é usada para especificar os pacotes base a serem verificados em busca de componentes gerenciados pelo Spring, 
como classes anotadas com `@Component`, `@Service`, `@Repository` ou `@Controller`.

A anotação `@ComponentScan` é usada em conjunto com a anotação `@Configuration` ou `@SpringBootApplication` para definir a configuração do contexto do Spring e permitir que o 
Spring encontre automaticamente e registre os componentes dentro dos pacotes especificados.

No exemplo dado, a anotação `@ComponentScan(basePackages = {"projeto.*"})` está configurada para escanear os pacotes que possuem o prefixo "projeto.". Isso significa que o Spring 
irá percorrer esses pacotes em busca de classes anotadas com `@Component`, `@Service`, `@Repository` ou `@Controller` para serem registradas como beans gerenciados pelo Spring.

Essa anotação é útil quando você possui componentes personalizados que precisam ser reconhecidos e gerenciados pelo Spring, permitindo que você aproveite a injeção de dependência, 
a configuração automática e outros recursos do Spring Framework.

Você pode ajustar os pacotes especificados no array `basePackages` para corresponder aos pacotes relevantes do seu projeto. Além disso, você também pode usar outras opções, como 
`basePackageClasses` para especificar as classes base ou `value` como um alias para `basePackages`.

Em resumo, a anotação `@ComponentScan` permite ao Spring encontrar automaticamente componentes em pacotes específicos e registrá-los como beans gerenciados pelo Spring. Isso 
facilita o desenvolvimento e configuração de aplicativos Spring, pois você não precisa registrar manualmente cada componente individualmente.

------------- // -------------

A anotação `@Repository` é uma anotação do Spring Framework que é usada para indicar que uma classe é responsável por acessar e manipular dados persistentes, geralmente em um 
banco de dados. 

A anotação `@Repository` é uma especialização da anotação `@Component`, o que significa que uma classe anotada com `@Repository` será tratada como um componente pelo Spring e 
será elegível para injeção de dependência e outras funcionalidades fornecidas pelo Spring.

O propósito principal da anotação `@Repository` é fornecer um meio para categorizar e identificar classes que atuam como repositórios de dados. Esses repositórios são responsáveis 
por fornecer uma abstração para o acesso a dados persistentes, encapsulando detalhes específicos do armazenamento de dados, como consultas SQL ou interações com o banco de dados.

Ao usar a anotação `@Repository`, você permite que o Spring realize a injeção de dependência automaticamente em outras classes que dependem desse repositório. Além disso, a 
anotação `@Repository` também oferece recursos adicionais, como a tradução automática de exceções específicas do banco de dados para exceções de persistência do Spring.

Embora o uso da anotação `@Repository` seja opcional, é uma prática comum aplicá-la a classes que atuam como repositórios de dados, pois ela ajuda na organização e semântica do 
código, além de fornecer recursos adicionais fornecidos pelo Spring.

É importante observar que a anotação `@Repository` faz parte do contexto do Spring Data, que é uma subestrutura do Spring Framework que fornece abstrações e recursos adicionais 
para acesso a dados. Portanto, seu uso é frequentemente associado ao Spring Data JPA, Spring Data JDBC, Spring Data MongoDB e outras implementações do Spring Data.

Em resumo, a anotação `@Repository` é usada para marcar uma classe como um repositório de dados, permitindo que o Spring a gerencie como um componente e forneça recursos 
adicionais para acesso a dados persistentes.

------------- // -------------

A anotação `@Transactional` é uma anotação do Spring Framework que é usada para indicar que um método ou classe deve ser executado dentro de um contexto transacional. 

Quando um método é anotado com `@Transactional`, o Spring cuida da criação e gerenciamento de uma transação para esse método. Transações são utilizadas para garantir a atomicidade, 
consistência, isolamento e durabilidade (ACID) das operações em um banco de dados ou outro recurso transacional.

A anotação `@Transactional` pode ser aplicada a um método específico ou a toda uma classe. Quando aplicada a um método específico, somente esse método será executado em uma 
transação. Se aplicada a uma classe, todos os métodos dentro dessa classe serão executados em uma transação.

Ao utilizar a anotação `@Transactional`, você pode obter vários benefícios:

1. Gerenciamento automático de transações: O Spring cuida da criação, commit e rollback de transações, tornando o código mais simples e livre de preocupações com o controle manual 
   de transações.

2. Suporte a várias estratégias de transação: O Spring suporta várias estratégias de transação, como transações baseadas em anotações, transações programáticas e transações 
   declarativas baseadas em XML. Você pode configurar a estratégia de transação adequada para suas necessidades.

3. Controle de isolamento e propagação da transação: A anotação `@Transactional` permite que você especifique o nível de isolamento da transação e a propagação para outros métodos 
   chamados. Isso garante a consistência e o comportamento esperado das transações em diferentes cenários.

4. Tratamento de exceções e rollback: O Spring trata exceções lançadas dentro de um método transacional e realiza o rollback da transação em caso de exceção não tratada. Isso 
   garante que as operações sejam revertidas adequadamente em caso de falhas.

É importante ressaltar que a anotação `@Transactional` deve ser usada com cuidado e em conjunto com um mecanismo de gerenciamento de transações adequado, como o Spring 
Transaction Management. Além disso, é importante considerar os detalhes de configuração e a configuração do ambiente para garantir o comportamento desejado das transações.

Em resumo, a anotação `@Transactional` é usada para marcar métodos ou classes que devem ser executados dentro de um contexto transacional, permitindo que o Spring gerencie 
automaticamente as transações e forneça recursos avançados, como controle de isolamento, propagação, tratamento de exceções e rollback.

------------- // -------------

A classe `CrudRepository<T, ID>` faz parte do Spring Data e é uma interface genérica fornecida pelo Spring Framework para facilitar a criação de repositórios de acesso a dados.

Vamos analisar cada um dos parâmetros utilizados na classe `CrudRepository<Pessoa, Long>`:

1. `T` é o tipo de entidade (modelo de dados) com o qual o repositório está lidando. No exemplo dado, `Pessoa` é o tipo da entidade que o repositório manipulará. Você substituirá 
   `Pessoa` pelo nome da sua entidade.

2. `ID` é o tipo do identificador único da entidade. O `ID` pode ser um tipo primitivo, como `Long`, `Integer`, `String`, ou um tipo personalizado. No exemplo dado, o identificador 
   único da entidade `Pessoa` é do tipo `Long`. Mais uma vez, você substituirá `Long` pelo tipo adequado do identificador da sua entidade.

A classe `CrudRepository` fornece um conjunto de métodos prontos para uso para realizar operações CRUD (Create, Read, Update, Delete) no banco de dados. Alguns dos métodos mais 
comuns fornecidos pela `CrudRepository` incluem:

- 'save(entity)': Salva ou atualiza uma entidade no banco de dados.
- 'findById(id)': Recupera uma entidade pelo seu identificador único.
- 'findAll()': Recupera todas as entidades do tipo especificado.
- 'delete(entity)': Exclui uma entidade do banco de dados.
- 'count()': Retorna o número total de entidades no repositório.

Esses métodos e outros estão disponíveis na classe `CrudRepository`, permitindo que você execute operações básicas de CRUD sem a necessidade de escrever código repetitivo. No 
entanto, a `CrudRepository` é uma interface genérica e precisa ser estendida por uma interface personalizada ou uma classe concreta para ser utilizada.

Ao estender a `CrudRepository`, você pode adicionar métodos personalizados para atender às necessidades específicas do seu domínio, se necessário.

Por exemplo, se você estender a `CrudRepository<Pessoa, Long>` com uma interface chamada `PessoaRepository`, você poderá utilizar métodos herdados, como `findById`, `save`, 
`findAll`, etc., além de adicionar métodos personalizados, como `findByNome` ou `findByEmail`.

Em resumo, a classe `CrudRepository` é uma interface genérica do Spring Data que fornece operações básicas de CRUD para acesso a dados. Você pode estender essa interface e 
personalizá-la para manipular entidades específicas do seu domínio no banco de dados.

------------- // -------------

A anotação `@EnableJpaRepositories` é uma anotação do Spring Framework que é usada para habilitar os recursos de repositórios JPA (Java Persistence API) fornecidos pelo Spring 
Data JPA.

Essa anotação é tipicamente usada em uma classe de configuração do Spring, geralmente uma classe anotada com `@Configuration` ou uma classe de inicialização do aplicativo anotada 
com `@SpringBootApplication`.

Ao utilizar a anotação `@EnableJpaRepositories`, você está ativando a funcionalidade de repositórios JPA do Spring Data para o projeto. A anotação permite que você defina as 
configurações para os repositórios JPA, como a localização dos repositórios e outras opções de configuração.

A opção `basePackages` é usada para especificar o pacote (ou pacotes) onde os repositórios JPA estão localizados. No exemplo dado, `projeto.springboot.repository` é o pacote base 
onde os repositórios JPA estão localizados. Isso indica ao Spring Data JPA onde procurar por interfaces de repositório para implementação automática.

Ao definir o pacote base através da opção `basePackages`, o Spring Data JPA irá escanear esse pacote e seus subpacotes em busca de interfaces de repositório anotadas com 
`@Repository` ou outras anotações específicas do Spring Data JPA.

Uma vez que as interfaces de repositório são encontradas, o Spring Data JPA irá gerar automaticamente a implementação dessas interfaces em tempo de execução, fornecendo assim a 
funcionalidade de acesso a dados para as entidades correspondentes.

É importante mencionar que a anotação `@EnableJpaRepositories` também oferece outras opções de configuração, como `entityManagerFactoryRef`, `transactionManagerRef` e 
`repositoryImplementationPostfix`, que permitem personalizar ainda mais o comportamento dos repositórios JPA.

Em resumo, a anotação `@EnableJpaRepositories` é usada para habilitar a funcionalidade de repositórios JPA do Spring Data. Através dessa anotação, você pode especificar o pacote 
base onde os repositórios JPA estão localizados, permitindo que o Spring Data JPA os encontre, gere as implementações automaticamente e forneça acesso a dados para suas entidades.


------------- // -------------

A anotação `@EnableTransactionManagement` é uma anotação do Spring Framework que é usada para habilitar o suporte a transações em um aplicativo Spring.

Ao utilizar a anotação `@EnableTransactionManagement`, você está ativando o suporte a transações do Spring Framework, permitindo que você utilize transações declarativas no seu 
código.

Essa anotação é tipicamente usada em uma classe de configuração do Spring, geralmente uma classe anotada com `@Configuration` ou uma classe de inicialização do aplicativo anotada 
com `@SpringBootApplication`.

Ao habilitar o suporte a transações com `@EnableTransactionManagement`, você pode usar anotações como `@Transactional` em métodos de negócio ou serviços para indicar que eles 
devem ser executados dentro de uma transação.

A anotação `@Transactional` é responsável por iniciar, gerenciar e finalizar transações automaticamente para os métodos anotados. Quando um método anotado com `@Transactional` é 
chamado, uma transação é criada e o contexto da transação é definido. O Spring gerencia automaticamente o início e o fim da transação, além de lidar com o commit ou rollback da 
transação, dependendo do resultado do método.

Além disso, a anotação `@EnableTransactionManagement` também permite que você configure um gerenciador de transações personalizado, como um `PlatformTransactionManager`, para 
controlar o comportamento das transações.

Ao habilitar o suporte a transações, você pode alcançar os seguintes benefícios:

- Atomicidade: As transações são executadas como uma unidade indivisível, onde todas as operações são confirmadas ou revertidas em conjunto.
- Consistência: As transações garantem que os dados estejam em um estado consistente antes e após sua execução.
- Isolamento: As transações oferecem isolamento, permitindo que elas sejam executadas independentemente de outras transações em andamento.
- Durabilidade: As transações confirmadas são permanentes e não serão perdidas mesmo em caso de falhas ou reinicialização do sistema.

Em resumo, a anotação `@EnableTransactionManagement` é usada para habilitar o suporte a transações no Spring Framework. Isso permite que você utilize a anotação `@Transactional` 
para marcar métodos que devem ser executados em uma transação, facilitando o gerenciamento e a consistência dos dados no seu aplicativo.

------------- // -------------

<tr th:each="pessoa : ${pessoas}">

Essa propriedade "${pessoas}" vai vir do banco de dados.
A propriedade "pessoa" é o que vai ser mostrado na tela.

------------- // -------------


A classe ModelAndView é uma classe do Spring Framework que é usada para encapsular dados do modelo e informações da visualização em um objeto.

A classe ModelAndView é frequentemente utilizada em controladores do Spring MVC para fornecer dados ao modelo e especificar a visualização que será renderizada e retornada ao 
cliente.

A principal finalidade da classe ModelAndView é fornecer uma maneira conveniente de transmitir dados do controlador para a visualização, além de permitir que você especifique a 
visualização que deve ser renderizada.

Ao criar uma instância de ModelAndView, você pode definir o nome da visualização (o nome lógico da visualização configurada em seu aplicativo) e adicionar atributos ao modelo 
(dados que serão utilizados pela visualização para renderizar a resposta).

Ao retornar o objeto ModelAndView no método do controlador, o Spring MVC utilizará o nome da visualização para determinar a visualização que deve ser renderizada. Os atributos do modelo serão disponibilizados para a visualização para que ela possa usar os dados na renderização da resposta.

No exemplo, o Spring MVC procuraria pela visualização chamada "cadastro/cadastropessoa" e a renderizaria usando os dados fornecidos no modelo.

Além disso, a classe ModelAndView também oferece métodos para configurar outras propriedades, como status HTTP, cabeçalhos de resposta e redirecionamentos.

Em resumo, a classe ModelAndView é usada para encapsular dados do modelo e informações da visualização em um objeto no Spring Framework. Ela permite que você especifique o nome 
da visualização e adicione atributos ao modelo, facilitando a passagem de dados do controlador para a visualização.


------------- // -------------

Instalando o Materialize CSS Design - https://materializecss.com/

Vamos baixar o materialize e colocá-lo dentro da pasta "static" projeto. Dentro dessa pasta que fica todos os recursos de css, de imagem e etc...
Site: https://materializecss.com/getting-started.html

Declarar nas páginas os imports (dentro do head):
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
 
 <!--Import materialize.css - São dois arquivos css -->
<link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>

OBS. Não esquece de renomear o caminho href. Exemplificado abaixo:

<link type="text/css" rel="stylesheet" href="materialize/css/materialize.css"  media="screen,projection"/>
<link type="text/css" rel="stylesheet" href="materialize/css/materialize.min.css"  media="screen,projection"/>


Por fim a declaração do javascript que vai ficar no corpo.
<!--JavaScript at end of body for optimized loading - São dois arquivos css -->-->
<script type="text/javascript" src="js/materialize.min.js"></script>

OBS. Não esquece de renomear o caminho href. Exemplificado abaixo:

<script type="text/javascript" src="materialize/js/materialize.js"></script>
<script type="text/javascript" src="materialize/js/materialize.min.js"></script>

Por exemplo, vamos customizar o botão, podemos copiar a class materialize e colar na tag button. 
https://materializecss.com/buttons.html

Como estava antes:

<label>Nome:</label>
<input name="nome" />
			
<label>Sobrenome:</label>
<input name="sobrenome" />
			
<label>Idade:</label>
<input name="idade" />

------------- // -------------

<td><a th:href="@{/editarpessoa/{idpessoa}(idpessoa=${pessoa.id})}">Editar</a></td>

"idpessoa" é a variavel onde vai ser capturado o id da pessoa. Essa variavel vai ser passada como parametro no método GET no editar para que possamos recuperar os objetos 
(os dados) da pessoa para poder jogar na tela e alterar.

Em tela:
<form action="salvarpessoa" method="post" th:object="${pessoaobj}">

No controller:
modelAndView.addObject("pessoaobj", pessoa.get());

O objetivo em editar a pessoa é buscar os valores da pessoa e jogar na tela, para isso vamos utilizar a propriedade "object" na tag do formulário onde esse objeto vai ser 
carregado através do controller na declaração do nome "objectpessoa". E para conseguir editar esse objeto vai precisar do id na tela e vamos utilizar o thymeleaf para isso, no 
caso, o atributo "field" fará essa função de especificar qual o id está sendo atualizado.

------------- // -------------

Na action do formulario telefone temos que passar a chave da pessoa para poder relacionar o telefone ao determinado código da pessoa. Ou seja, temos que pegar o id da pessoa e
enviar junto com os dados do telefone para que na hora de salvar o novo telefone possa passar para o cadastro de telefone o código da pessoa e ele poder salvar no banco de dados.

------------- // -------------

A anotação `@Valid` e a classe `BindingResult` estão relacionadas à validação de dados em um framework como o Spring MVC. Vou explicar cada um deles:

A anotação `@Valid` é usada para indicar que um objeto deve ser validado de acordo com as regras de validação definidas em sua classe. Ao marcar um parâmetro de método com 
`@Valid`, você está instruindo o framework a executar a validação desse objeto antes de prosseguir com o processamento do método.

Por exemplo, suponha que você tenha uma classe `Pessoa` com campos como nome, idade, email, etc., e tenha definido anotações de validação em alguns desses campos, como 
`@NotNull`, `@NotEmpty`, `@Email`, etc. Ao usar `@Valid` no parâmetro `Pessoa pessoa` do método, você está solicitando ao framework para validar automaticamente os dados dessa 
pessoa com base nas anotações de validação definidas em sua classe.

A classe `BindingResult` é uma classe fornecida pelo framework que contém os resultados da validação. Ela é usada em conjunto com a anotação `@Valid`. Após a validação do objeto 
marcado com `@Valid`, o `BindingResult` é usado para verificar se ocorreram erros de validação e para acessar informações sobre esses erros.

Por exemplo, você pode usar o `BindingResult` para verificar se há erros de validação chamando o método `hasErrors()`. Se houver erros, você pode acessar cada erro individualmente 
usando métodos como `getAllErrors()` para obter uma lista de todos os erros, `getFieldErrors()` para obter apenas os erros de campo específicos ou `getGlobalErrors()` para obter 
erros globais relacionados ao objeto em geral.

O `BindingResult` também fornece métodos para acessar informações adicionais sobre os erros, como as mensagens de erro padrão definidas nas anotações de validação 
(`getDefaultMessage()`), o nome do campo associado a um erro (`getField()`), o valor rejeitado (`getRejectedValue()`), entre outros.

Em resumo, a anotação `@Valid` instrui o framework a validar um objeto com base em suas anotações de validação, enquanto a classe `BindingResult` é usada para obter os resultados 
dessa validação, incluindo informações sobre erros de validação encontrados. 

------------- // -------------

Vale ressaltar que se validar do lado do cliente (utilizando o javascript) não utiliza recurso do servidor, ou seja, gera menos impacto comparado ao que foi validado do lado do 
servidor (controller).

---------------------------------------------------------------------------------- // -------------------------------------------------------------------------------------------

                                                                 < Configurando Spring Security em memória >

A classe `WebSecurityConfigurerAdapter` é uma classe fornecida pelo Spring Security que fornece uma configuração básica para a segurança de aplicativos web. Ela é uma classe 
abstrata que pode ser estendida para personalizar a configuração de segurança do aplicativo.

Ao estender a classe `WebSecurityConfigurerAdapter` e sobrescrever seus métodos, você pode definir as regras de segurança para o seu aplicativo, como autenticação, autorização e 
configurações específicas do protocolo HTTP.

A classe `WebSecurityConfigurerAdapter` possui vários métodos que podem ser sobrescritos para personalizar a configuração de segurança. Alguns dos métodos mais comumente usados 
incluem:

- `configure(AuthenticationManagerBuilder auth)`: permite configurar o mecanismo de autenticação do aplicativo. Você pode definir as fontes de autenticação, como banco de dados, 
                                                  serviço LDAP ou provedor de autenticação personalizado.

- `configure(HttpSecurity http)`: permite configurar as regras de autorização e configurações específicas do protocolo HTTP. Você pode definir quais URLs exigem autenticação, 
                                  quais papéis de usuário têm acesso a determinadas URLs, configurações de sessão, proteção CSRF, CORS e outras configurações de segurança.

- `configure(WebSecurity web)`: permite configurar a segurança para recursos específicos do Spring Security, como o Ignorar configuração para recursos estáticos (CSS, JavaScript, etc.).

- `userDetailsService()`: retorna uma instância de `UserDetailsService`, que pode ser usada para personalizar a autenticação baseada em banco de dados ou outras fontes de dados.

Ao estender a classe `WebSecurityConfigurerAdapter` e sobrescrever esses métodos, você pode fornecer a configuração personalizada para a segurança do seu aplicativo, adaptando-a 
às suas necessidades específicas.


Essa classe é amplamente utilizada para configurar a segurança em aplicativos web Spring, permitindo a definição de políticas de autenticação e autorização de forma flexível e 
adaptável.

------------- // ------------- 
 
A anotação `@Configuration` é uma anotação fornecida pelo Spring Framework que indica que uma classe é uma classe de configuração. Essa anotação é usada para configurar e definir 
beans no contexto de aplicativos Spring.

Quando uma classe é anotada com `@Configuration`, ela é tratada como uma fonte de definições de configuração para o aplicativo. Isso significa que a classe contém métodos que são 
responsáveis por criar e configurar beans do Spring, que são objetos gerenciados pelo contêiner do Spring.

Os principais pontos a serem observados sobre a anotação `@Configuration` são:

1. Identificação de Classe de Configuração: A anotação `@Configuration` informa ao Spring que a classe é uma classe de configuração. Isso significa que ela contém definições e 
                                            configurações para o aplicativo.

2. Métodos Anotados com `@Bean`: Dentro de uma classe anotada com `@Configuration`, você pode ter métodos anotados com `@Bean`. Esses métodos são responsáveis por criar e 
                                 configurar os beans do Spring. O retorno desses métodos é o objeto que será gerenciado pelo contêiner do Spring.

3. Criação de Beans: Os métodos anotados com `@Bean` retornam objetos que são gerenciados pelo contêiner do Spring. Esses objetos podem ser instâncias de classes próprias, 
                     componentes de terceiros ou até mesmo objetos criados manualmente.

4. Injeção de Dependências: A anotação `@Configuration` trabalha em conjunto com outras anotações do Spring, como `@Autowired`, permitindo a injeção de dependências nos beans 
                            criados. Isso facilita a configuração e a conexão de diferentes componentes do aplicativo.

Em resumo, a anotação `@Configuration` é usada para marcar uma classe como uma classe de configuração no contexto do Spring. Essa anotação permite a definição e configuração de 
beans do Spring por meio de métodos anotados com `@Bean`, permitindo a criação de objetos gerenciados pelo contêiner do Spring e a configuração de dependências entre eles.

------------- // ------------- 

A anotação `@EnableWebSecurity` é uma anotação fornecida pelo Spring Security que habilita a segurança web no aplicativo. Essa anotação é usada em conjunto com a classe de 
configuração que estende `WebSecurityConfigurerAdapter` para configurar as medidas de segurança no aplicativo.

Quando você adiciona a anotação `@EnableWebSecurity` em sua classe de configuração, você está ativando a segurança web fornecida pelo Spring Security. Isso permite que você 
defina regras de segurança, configure autenticação e autorização, e aplique outras medidas de proteção em seu aplicativo web.

A anotação `@EnableWebSecurity` habilita o módulo de segurança web do Spring Security e, por padrão, cria uma instância do filtro `springSecurityFilterChain`. Esse filtro é 
responsável por interceptar e processar as requisições HTTP, aplicando as configurações de segurança definidas na classe de configuração.

Além disso, a anotação `@EnableWebSecurity` também permite a personalização da configuração de segurança através da sobrescrita do método `configure` na classe que estende 
`WebSecurityConfigurerAdapter`. Esse método permite que você defina as regras de autenticação, autorização e outras configurações de segurança específicas para o seu aplicativo.

Em resumo, a anotação `@EnableWebSecurity` é usada para habilitar a segurança web no aplicativo Spring utilizando o Spring Security. Ela permite que você configure as medidas de 
segurança, como autenticação e autorização, e personalize as configurações de segurança do aplicativo web.

------------- // ------------- 

O script representa um método sobrescrito chamado `configure` na classe que estende `WebSecurityConfigurerAdapter`. Esse método é usado para configurar as regras de segurança para 
o aplicativo web.

Explicação de cada linha do script:

1. `@Override`: Essa anotação indica que o método está sobrescrevendo um método da classe pai.

2. `protected void configure(HttpSecurity http) throws Exception`: Este é o cabeçalho do método `configure` que recebe um objeto `HttpSecurity`. O `HttpSecurity` é usado para 
                                                                   configurar as regras de segurança do aplicativo.

3. `http.csrf().disable()`: Desabilita a proteção CSRF (Cross-Site Request Forgery), que é uma medida de segurança para prevenir ataques de falsificação de solicitação entre 
                            sites. Neste caso, a proteção CSRF está sendo desabilitada.

4. `authorizeRequests()`: Inicia a configuração das regras de autorização.

5. `antMatchers(HttpMethod.GET, "/").permitAll()`: Permite que todas as solicitações GET para a raiz ("/") sejam acessadas sem autenticação. Isso significa que a página inicial 
                                                   do aplicativo estará acessível para todos.

6. `anyRequest().authenticated()`: Requer autenticação para qualquer outra solicitação que não tenha sido configurada anteriormente. Isso significa que, para todas as outras 
                                   solicitações que não são GET para a raiz, é necessária autenticação.

7. `formLogin().permitAll()`: Permite que todas as solicitações de login (formulário de login) sejam acessadas sem autenticação. Isso significa que a página de login estará 
                              acessível para todos.

8. `logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout"))`: Configura o logout para a URL "/logout". Quando uma solicitação GET ou POST é feita para essa URL, o 
                                                                          usuário será desconectado e redirecionado para a página de login.

Em resumo, esse método de configuração define as regras de segurança para o aplicativo web. Ele desabilita a proteção CSRF, permite o acesso sem autenticação à página inicial e 
ao formulário de login, requer autenticação para todas as outras solicitações e configura a URL de logout.

------------- // -------------

Esse script representa um método sobrescrito chamado `configure` na classe que estende `WebSecurityConfigurerAdapter`. Esse método é usado para configurar o gerenciador de 
autenticação para o aplicativo web.

Explicação de cada linha do script:

1. `@Override`: Essa anotação indica que o método está sobrescrevendo um método da classe pai.

2. `protected void configure(AuthenticationManagerBuilder auth) throws Exception`: Este é o cabeçalho do método `configure` que recebe um objeto `AuthenticationManagerBuilder`. 
                                                                                   O `AuthenticationManagerBuilder` é usado para configurar o gerenciador de autenticação do aplicativo.

3. `auth.inMemoryAuthentication()`: Configura a autenticação em memória, o que significa que as informações de autenticação serão armazenadas em memória.

4. `passwordEncoder(NoOpPasswordEncoder.getInstance())`: Configura o codificador de senha a ser usado para autenticação em memória. Neste caso, está sendo utilizado 
                                                         `NoOpPasswordEncoder`, que não faz nenhuma codificação ou hash na senha. No entanto, o uso de `NoOpPasswordEncoder` não 
                                                         é recomendado em ambientes de produção, pois as senhas ficam expostas em texto simples. É preferível utilizar um 
                                                         codificador seguro, como BCryptPasswordEncoder.

5. `withUser("admin")`: Define um usuário com o nome "admin".

6. `password("123")`: Define a senha do usuário como "123".

7. `roles("ADMIN")`: Atribui a função (role) "ADMIN" ao usuário. Essa função pode ser usada para restringir o acesso a determinadas partes do aplicativo com base nas permissões 
                     associadas a essa função.

Em resumo, esse método de configuração define um gerenciador de autenticação em memória para o aplicativo web. Ele cria um usuário com nome "admin", senha "123" e atribui a 
função "ADMIN" a esse usuário. Esse usuário pode ser usado para autenticação durante o processo de login do aplicativo. É importante observar que esse exemplo de autenticação em 
memória é apenas para fins de demonstração e não é adequado para um ambiente de produção, onde é recomendado o uso de um sistema de autenticação mais robusto, como autenticação 
baseada em banco de dados ou integração com provedores de autenticação externos.

------------- // -------------

Esse script representa um método chamado `configure` na classe que estende `WebSecurityConfigurerAdapter`. Esse método é usado para 
configurar a segurança para recursos estáticos específicos que estão fora do escopo da segurança do Spring Security.

Explicação do script:

1. `public void configure(WebSecurity web) throws Exception`: Este é o cabeçalho do método `configure` que recebe um objeto `WebSecurity`. O `WebSecurity` é usado para configurar 
                                                              a segurança para recursos estáticos.

2. `web.ignoring()`: Indica que determinados recursos estáticos devem ser ignorados pela configuração de segurança do Spring Security.

3. `antMatchers("/materialize/**")`: Especifica os padrões de URL que correspondem aos recursos estáticos que devem ser ignorados. Nesse caso, os recursos que correspondem a 
                                     qualquer URL que comece com "/materialize/" serão ignorados.

Ao usar `web.ignoring().antMatchers(...)`, você está instruindo o Spring Security a ignorar a aplicação de regras de segurança para os recursos estáticos especificados. Isso 
significa que qualquer solicitação para os recursos estáticos correspondentes não será interceptada pelo Spring Security e não exigirá autenticação ou autorização.

No exemplo fornecido, os recursos estáticos sob o diretório "/materialize" estão sendo ignorados pela configuração de segurança. Isso pode ser útil quando você tem bibliotecas 
ou arquivos CSS, JavaScript ou imagens que não precisam ser protegidos pela segurança do Spring Security.

É importante observar que, ao configurar a segurança para recursos estáticos, você deve garantir que esses recursos não contenham informações confidenciais ou restritas, pois 
eles não serão protegidos pelo Spring Security.

---------------------------------------------------------------------------------- // -------------------------------------------------------------------------------------------
      < Estrutura de classes Spring Security com Banco de Dados >

              1
         ____________                    __________________
        | UserDetails |                  | UserRepository |
        |_____________|                  |________________|
               ^                               ^  |
               |                               |  |
               |                               |  |
               |                               |  v
         _________                        _____________________
        | Usuario |                       | UserDetailsService |
        |[tabela] | --------------------  |____________________|
        |_________|          |
                         Web Security
 


O `UserDetails` é uma interface do Spring Security que define os detalhes de um usuário autenticado no sistema. Essa interface fornece informações necessárias para o Spring 
Security realizar a autenticação e autorização.

A interface `UserDetails` define os seguintes métodos que devem ser implementados:

- `Collection<? extends GrantedAuthority> getAuthorities()`: Retorna uma coleção de objetos `GrantedAuthority`, que representam as permissões ou papéis (roles) do usuário autenticado.

- `String getPassword()`: Retorna a senha do usuário. É importante notar que, por razões de segurança, o retorno desse método geralmente é a senha criptografada ou codificada de 
                          alguma forma.

- `String getUsername()`: Retorna o nome de usuário do usuário autenticado.

- `boolean isAccountNonExpired()`: Indica se a conta do usuário não está expirada.

- `boolean isAccountNonLocked()`: Indica se a conta do usuário não está bloqueada.

- `boolean isCredentialsNonExpired()`: Indica se as credenciais do usuário (por exemplo, senha) não estão expiradas.

- `boolean isEnabled()`: Indica se a conta do usuário está habilitada.

2. **Implementação da interface UserDetails:**

Normalmente, você implementa a interface `UserDetails` em uma classe de usuário personalizada que representa os detalhes de um usuário autenticado em seu sistema. Essa classe 
geralmente contém informações como nome de usuário, senha, permissões, papéis (roles) e outros atributos relacionados ao usuário.

3. **Utilização do UserDetails no processo de autenticação e autorização:**

Ao usar o Spring Security, os objetos `UserDetails` são normalmente retornados pelo `UserDetailsService`, que é uma interface usada para carregar os detalhes do usuário a partir 
de uma origem de dados, como um banco de dados. O `UserDetailsService` é responsável por fornecer os detalhes do usuário com base em um nome de usuário fornecido durante o 
processo de autenticação.

Os detalhes do usuário fornecidos pelo `UserDetailsService` são então usados pelo Spring Security para autenticar o usuário e verificar as permissões e restrições de acesso.

Essa estrutura do `UserDetails` no Spring Security permite que você personalize o processo de autenticação e autorização, fornecendo informações específicas do usuário no 
contexto do seu sistema.

Lembre-se de que a implementação específica da interface `UserDetails` pode variar dependendo do seu sistema e da forma como você deseja armazenar e gerenciar os detalhes do 
usuário. É possível personalizar a implementação para se adequar às necessidades do seu aplicativo, como integração com um banco de dados de usuários ou um provedor de 
autenticação externo.

------------- // -------------

A interface CrudRepository possui métodos padrão para realizar as operações básicas de CRUD, como salvar (save), atualizar (save), excluir (delete), buscar por ID (findById) e 
buscar todos (findAll).

Ao estender a interface CrudRepository com os tipos apropriados, você herda esses métodos e pode utilizá-los para interagir com o banco de dados de forma fácil e conveniente, 
sem a necessidade de escrever código repetitivo.

A interface UsuarioRepository estende a CrudRepository com os tipos Usuario (a entidade que representa os dados do usuário) e Long (o tipo do ID da entidade).

Com isso, a interface UsuarioRepository herda automaticamente os métodos básicos de CRUD, permitindo que você execute operações de persistência, como salvar, atualizar, excluir 
e buscar usuários no banco de dados, sem a necessidade de implementar esses métodos manualmente.

Além dos métodos padrão, você também pode adicionar métodos personalizados na interface UsuarioRepository para realizar consultas mais específicas e personalizadas no banco de 
dados, utilizando a sintaxe do Spring Data JPA ou outros recursos fornecidos pelo Spring Data.

Essa abordagem do CrudRepository do Spring Data simplifica o desenvolvimento de operações de persistência básicas, tornando mais fácil e produtivo o trabalho com o banco de dados 
em aplicativos Spring.

------------- // -------------

A classe UserDetailsService é uma interface do Spring Security que define um contrato para carregar os detalhes de um usuário a partir de uma origem de dados, como um banco de dados, para fins de autenticação e autorização.

Aqui estão alguns pontos importantes sobre a classe UserDetailsService do Spring Security:

Objetivo do UserDetailsService:
O objetivo principal do UserDetailsService é carregar os detalhes do usuário com base em um nome de usuário fornecido durante o processo de autenticação. Esses detalhes são então 
usados pelo Spring Security para autenticar o usuário e verificar as permissões e restrições de acesso.

Método loadUserByUsername:
A interface UserDetailsService define um único método chamado loadUserByUsername. Esse método é responsável por carregar os detalhes do usuário com base em um nome de usuário.

O método recebe um parâmetro username que representa o nome de usuário do usuário a ser carregado. Ele retorna um objeto UserDetails que contém os detalhes do usuário, como nome 
de usuário, senha e permissões.

Se o usuário não for encontrado, o método loadUserByUsername deve lançar uma exceção UsernameNotFoundException para indicar que o usuário não existe.

Implementação do UserDetailsService:
Para utilizar a classe UserDetailsService, você precisa criar uma classe que implemente essa interface e fornecer uma implementação do método loadUserByUsername que carregue os 
detalhes do usuário da sua origem de dados, como um banco de dados.

------------- // ---------------

A fins de Estudo:
A anotação @Autowired é uma anotação do Spring Framework que é usada para realizar a injeção de dependência automaticamente em classes e componentes.

A injeção de dependência é um padrão de projeto amplamente utilizado que permite a criação de componentes independentes e facilita a manutenção, o teste e a reutilização de código. 
Com a injeção de dependência, as dependências de um objeto são fornecidas por um mecanismo externo, em vez de serem criadas ou gerenciadas internamente pelo objeto.

Ao usar a anotação @Autowired, você está indicando ao Spring que deseja que ele resolva e injete automaticamente as dependências para você.

Existem várias maneiras de usar a anotação @Autowired:
  1. Injeção de Dependência em Construtor;
  2. Injeção de Dependência em Método Setter;
  3. Injeção de Dependência em Atributo;

Lembre-se de que para que a injeção de dependência ocorra, é necessário que a classe a ser injetada (dependência) seja gerenciada pelo Spring, ou seja, também precisa estar 
anotada com @Component, @Service, @Repository ou outras anotações específicas do Spring.

Em resumo, a anotação @Autowired é usada para realizar a injeção de dependência automaticamente pelo Spring Framework, simplificando o processo de gerenciamento de dependências 
em um aplicativo Spring.

------------- // ---------------

Para testar vamos fazer um insert no usuário no banco de dados:
INSERT INTO public.usuario(
            id, login, senha)
    VALUES (1, 'admin', '$2a$10$t73SPdIn7BadIcSACXLsp.nHwwtTXZnY/4bRZFZCy5.kwZQo7CiZW');

------------- // ---------------

Criando controle de acessos e perfil (Roles) Spring Security


   |----------|                   |-------------|                    |----------|
   |  User    | ----------------> |  Acessos    | <----------------- | Roles    |
   |          |                   |-------------|                    |----------|
   |__________|                   |  UID  | RID |                  1 |admin     |
                                  |    1  |  1  |                  2 |secretaria|
                                  |    1  |  2  |                    ------------
                                   --------------


A interface GrantedAuthority faz parte do framework Spring Security e é usada para representar uma autoridade ou permissão concedida a um usuário autenticado. Ela define o 
contrato para classes que representam uma autoridade, ou seja, uma capacidade que um usuário possui dentro do sistema.

O método getAuthority() retorna uma string que representa a autoridade. Essa string geralmente corresponde a um papel, função ou permissão específica dentro do sistema.

Ao usar o Spring Security, as autoridades são associadas aos usuários autenticados e são usadas para controlar o acesso a recursos protegidos. Por exemplo, você pode ter 
autoridades como "ROLE_ADMIN", "ROLE_USER", "PERMISSION_WRITE", etc. Essas autoridades são concedidas aos usuários durante o processo de autenticação e podem ser usadas 
posteriormente para verificar se um usuário tem permissão para acessar determinado recurso.

Além da interface GrantedAuthority, o Spring Security fornece implementações padrão, como a classe SimpleGrantedAuthority, que implementa a interface e permite criar objetos de 
autoridade facilmente.

No geral, a interface GrantedAuthority é fundamental no Spring Security para representar e controlar as autoridades e permissões concedidas aos usuários autenticados.


----------- // -------------

A anotação @JoinTable é usada em mapeamentos de relacionamentos muitos-para-muitos no contexto de mapeamento objeto-relacional em frameworks como o Hibernate. Ela define uma 
tabela de junção que é usada para associar os registros de uma entidade com os registros de outra entidade relacionada.

No caso da anotação @JoinTable(name = "usuarios_role"), a tabela de junção será criada com o nome "usuarios_role". Essa tabela será usada para associar os registros da entidade 
atual (geralmente a classe de usuário) com os registros da entidade relacionada (geralmente a classe de função ou permissão).

A anotação @JoinTable geralmente é usada em conjunto com outras anotações, como @ManyToMany ou @OneToMany, para configurar o relacionamento entre as entidades. Essas anotações 
são usadas para definir a cardinalidade do relacionamento (muitos-para-muitos, um-para-muitos, etc.) e para especificar os campos de junção ou chaves estrangeiras usadas na 
tabela de junção.

No exemplo mencionado, a tabela de junção "usuarios_role" será criada para associar registros de usuários com registros de roles (funções ou permissões). Essa tabela de junção 
pode conter campos adicionais, como chaves estrangeiras para identificar os registros associados e qualquer outra informação relevante para o relacionamento.

É importante ressaltar que a configuração e o comportamento exato da anotação @JoinTable podem variar dependendo do framework de mapeamento objeto-relacional utilizado, como 
Hibernate, JPA (Java Persistence API) ou Spring Data JPA. Recomenda-se consultar a documentação do framework específico que você está utilizando para obter mais detalhes sobre o 
uso correto dessa anotação.

No exemplo mencionado, a anotação @JoinTable(name = "usuarios_role", joinColumns = @JoinColumn(name="usuario_id", referencedColumnName = "id", table = "usuário")) define a tabela 
de junção "usuarios_role" e suas colunas de junção. Vamos analisar cada parte dessa anotação:

name = "usuarios_role": Especifica o nome da tabela de junção como "usuarios_role".

joinColumns = @JoinColumn(name="usuario_id", referencedColumnName = "id", table = "usuário"): Define as colunas de junção da tabela de junção. Nesse caso, temos:

name = "usuario_id": Especifica o nome da coluna de junção como "usuario_id". Essa coluna representa a chave estrangeira referenciando a entidade de usuário.

referencedColumnName = "id": Especifica a coluna da entidade de usuário que é referenciada pela coluna de junção. Nesse caso, a coluna "id" da tabela "usuário" é referenciada 
pela coluna "usuario_id" da tabela de junção.

table = "usuário": Especifica o nome da tabela da entidade de usuário. Essa informação é necessária para mapear corretamente a coluna de junção à tabela de usuário.

Essa anotação define a configuração da tabela de junção "usuarios_role" para associar registros de usuário com registros de role (funções ou permissões). A coluna "usuario_id" 
na tabela de junção será uma chave estrangeira que faz referência à coluna "id" da tabela "usuário".

A anotação `inverseJoinColumns` é usada em conjunto com a anotação `@JoinTable` em relacionamentos muitos-para-muitos no contexto de mapeamento objeto-relacional. Ela permite 
especificar as colunas de junção da tabela de junção que correspondem à entidade relacionada.

No exemplo mencionado, a anotação `inverseJoinColumns = @JoinColumn(name="role_id", referencedColumnName = "id", table = "role")` define as colunas de junção da tabela de junção 
que estão relacionadas à entidade de "role" (função ou permissão). Vamos analisar cada parte dessa anotação:

- `name = "role_id"`: Especifica o nome da coluna de junção como "role_id". Essa coluna representa a chave estrangeira referenciando a entidade de role na tabela de junção.

- `referencedColumnName = "id"`: Especifica a coluna da entidade de role que é referenciada pela coluna de junção. Nesse caso, a coluna "id" da tabela "role" é referenciada pela 
coluna "role_id" da tabela de junção.

- `table = "role"`: Especifica o nome da tabela da entidade de role. Essa informação é necessária para mapear corretamente a coluna de junção à tabela de role.

Essa anotação `inverseJoinColumns` é usada em conjunto com `joinColumns` para definir as colunas de junção na tabela de junção que estabelecem o relacionamento entre as entidades 
envolvidas.

No contexto do exemplo mencionado, a anotação `inverseJoinColumns` especifica as colunas de junção que se referem à entidade de role. Portanto, a tabela de junção "usuarios_role" 
terá uma coluna "role_id" que representa a chave estrangeira que faz referência à coluna "id" da tabela "role".

Lembrando que o comportamento e a configuração exata da anotação `inverseJoinColumns` podem variar dependendo do framework de mapeamento objeto-relacional utilizado, como 
Hibernate, JPA ou Spring Data JPA. Consulte a documentação do framework específico para obter informações detalhadas sobre o uso correto dessa anotação.


Para Melhor entendimento - Modelo Relacional:

usuario(id, login, senha)
role(id, nome_role)
Usuarios_role(usuario_id, role_id)

usuario_id referencia id da tabela usuario
role_id referencia id da tabela role

         | --------|                                 |------|
         | Usuario |---------------------------------| Role | 
         |_________|               |                 | _____|
                                   |
                                   |
                          |----------------------|
                          |    usuarios_role     |
                          |______________________|
                          
Criando os valores na tabela do banco de dados:

NSERT INTO public.role(
            id, nome_role)
    VALUES (1, 'ROLE_ADMIN'), (2, 'ROLE_USER'), (3, 'ROLE_GERENTE');

SELECT * FROM role;

SELECT * FROM usuario;

INSERT INTO public.usuarios_role(
            usuario_id, role_id)
    VALUES (1, 1), (1,3);

    
SELECT * FROM usuarios_role;

------------- // ---------------

.antMatchers(HttpMethod.GET, "/cadastropessoa") especifica que a configuração a seguir se aplica ao método HTTP GET da URL "/cadastropessoa".

.hasAnyRole("ADMIN") define a restrição de acesso para essa URL. A expressão hasAnyRole("ADMIN") indica que apenas usuários com a função (role) "ADMIN" têm permissão para acessar 
essa URL.

Portanto, esse script define uma regra de segurança que permite apenas usuários com a função "ADMIN" acessarem a URL "/cadastropessoa" usando o método HTTP GET. Outros usuários 
sem essa função terão acesso negado a essa URL.

------------- // ---------------

Corrigindo um bug:
Esse bug se refere na unicidade UNIQUE(role_id) que especifica o tipo de restrição que está sendo adicionada, neste caso, uma restrição de chave única. Isso significa que o 
valor da coluna "role_id" em cada registro da tabela deve ser exclusivo, ou seja, não pode haver duplicatas. Ou seja, ele gerou 
uma chave unica apenas para o role e queremos que seja gerado uma chave unica para o usuario_id e o role_id.
  
  ALTER TABLE public.usuarios_role ADD CONSTRAINT uk_krvk2qx218dxa3ogdyplk0wxw UNIQUE(role_id);

Logo para resolver isso, vamos no BD para apagar essa restrição e criar uma nova restrição:

ALTER TABLE public.usuarios_role
  ADD CONSTRAINT uk_krvk2qx218dxa3ogdyplk0wxw UNIQUE(role_id, usuario_id);
  
Com isso não poderá mais ter um usuário e um papel (role) repetido. Ou seja, o UNIQUE(role_id, usuario_id) especifica o tipo de restrição que está sendo adicionada, neste caso, 
uma restrição de chave única composta. Isso significa que a combinação de valores das colunas "role_id" e "usuario_id" em cada registro da tabela deve ser exclusiva, ou seja, 
não pode haver duplicatas dessa combinação de valores.

Em resumo, o SQL está adicionando uma restrição de chave única composta às colunas "role_id" e "usuario_id" da tabela "usuarios_role". Isso garante que cada combinação de valores 
nessas colunas seja única dentro da tabela, impedindo a duplicação dessa combinação específica.


Agora eu posso criar um usuario e inserir o papel admin ou qlq outro papel desde que não se repita a mesma linha.

INSERT INTO public.usuario(
            id, login, senha)
    VALUES (2, 'daniel', '$2a$10$WrmJJCXR4btYbqdf427EE.ch4agWV4eT6FUd24T5sEZ1xM85kh2ne');


INSERT INTO public.usuarios_role(
            usuario_id, role_id)
    VALUES (2, 1),(2, 3);

select * from usuarios_role;

-------------------------------------------------------------- // ---------------------------------------------------------------

A interface `WebMvcConfigurer` é uma interface do Spring Framework que permite a personalização da configuração do MVC (Model-View-Controller) da aplicação web. Ela é usada para 
configurar aspectos relacionados ao MVC, como a configuração de recursos estáticos, interceptadores, conversores, validadores, entre outros.

Ao implementar a interface `WebMvcConfigurer`, é possível personalizar o comportamento padrão do Spring MVC, adicionando ou substituindo configurações específicas. Além disso, 
essa interface permite estender a configuração existente, evitando a necessidade de substituir completamente a configuração padrão.

A `WebMvcConfigurer` fornece uma série de métodos que podem ser sobrescritos para realizar as configurações desejadas. Alguns dos métodos mais comumente utilizados incluem:

- `addResourceHandlers(ResourceHandlerRegistry registry)`: Permite configurar o mapeamento de recursos estáticos, como arquivos CSS, JavaScript e imagens.

- `addInterceptors(InterceptorRegistry registry)`: Permite adicionar interceptadores que podem ser executados antes ou após a execução de uma requisição. Os interceptadores são 
                                                   úteis para adicionar lógica de pré-processamento ou pós-processamento nas requisições.

- `addFormatters(FormatterRegistry registry)`: Permite adicionar conversores e formatadores personalizados para tipos de dados específicos usados em formulários.

- `addViewControllers(ViewControllerRegistry registry)`: Permite registrar controladores de visualização para mapear URLs diretamente para visualizações sem a necessidade de um 
                                                         método de controlador específico.

- `configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)`: Permite configurar o comportamento padrão do servlet para lidar com solicitações que não 
                                                                                 correspondem a nenhum mapeamento de controlador existente.

Esses são apenas alguns exemplos dos métodos disponíveis na interface `WebMvcConfigurer`. Ao implementar essa interface e sobrescrever os métodos relevantes, é possível 
personalizar e configurar o comportamento do MVC de acordo com as necessidades específicas da aplicação.

------------- // ---------------

Dentro desse método, estamos usando o objeto ViewControllerRegistry para configurar a rota "/login" e associá-la à visualização "/login".

A linha registry.addViewController("/login").setViewName("/login"); define a rota "/login" e a associa à visualização "/login". Isso significa que quando um usuário acessar a 
rota "/login", a visualização "/login" será retornada, sem a necessidade de um método de controle separado para lidar com essa requisição.

A linha registry.setOrder(Ordered.HIGHEST_PRECEDENCE); define a ordem de prioridade para essa configuração. Neste caso, estamos definindo a ordem como a mais alta 
(HIGHEST_PRECEDENCE), o que significa que essa configuração será aplicada antes de outras configurações de rota.

Essa abordagem é útil para casos em que uma rota simples precisa ser mapeada diretamente para uma visualização sem a necessidade de lógica adicional de controle. Isso pode ser 
útil, por exemplo, para páginas de login, páginas de erro personalizadas ou qualquer outra visualização estática que não exija processamento lógico adicional.

Lembrando que a configuração exata pode variar dependendo do framework e versão específicos do Spring MVC que estão sendo utilizados. É importante consultar a documentação 
oficial do Spring para obter informações mais detalhadas sobre a configuração de rotas e visualizações.

-------------- // ---------------

A expressão .anyRequest().authenticated() indica que todas as requisições que não foram correspondidas por regras de autorização específicas devem exigir autenticação. Isso 
significa que qualquer requisição feita pelo usuário, exceto as que foram configuradas de forma diferente, requer autenticação para serem acessadas.

Essa configuração é comumente usada para garantir que todas as rotas e recursos da aplicação estejam protegidos e exijam autenticação antes de serem acessados. Ela garante que 
apenas usuários autenticados possam acessar as páginas e recursos protegidos.

Ao usar .anyRequest().authenticated(), todas as requisições não especificadas por regras mais específicas (por exemplo, regras baseadas em funções de usuário ou URLs específicas) serão consideradas como requisições que exigem autenticação.

Em resumo, esse script configura a regra de autorização para todas as requisições não correspondidas por regras específicas. Exige que todas as requisições sejam autenticadas 
para serem acessadas. Essa configuração garante a proteção global da aplicação, exigindo autenticação para todas as partes não especificamente configuradas de forma diferente.

-------------- // ---------------

A expressão .and().formLogin() indica que uma configuração para o formulário de login está sendo adicionada à configuração existente.

A expressão .permitAll() permite que todas as solicitações de acesso à página de login sejam permitidas sem autenticação. Isso significa que qualquer usuário, mesmo aqueles que 
não estão autenticados, terá permissão para acessar a página de login.

Essa configuração é útil para permitir que os usuários acessem a página de login e insiram suas credenciais para realizar a autenticação. Sem essa configuração, eles seriam 
redirecionados para a página de login apenas após uma tentativa de acesso a uma página protegida.

Em resumo, esse script configura o formulário de login e permite que todas as solicitações de acesso à página de login sejam permitidas sem autenticação. Isso permite que os 
usuários acessem a página de login e forneçam suas credenciais para realizar o processo de autenticação.

-------------- // ---------------

A expressão .loginPage("/login") define a página de login personalizada para a aplicação. Quando um usuário não autenticado tenta acessar uma página protegida e é redirecionado 
para a página de login, a URL "/login" será usada como página de login.

A expressão .defaultSuccessUrl("/cadastropessoa") define a URL padrão para onde o usuário será redirecionado após fazer login com sucesso. Nesse caso, após o login bem-sucedido, 
o usuário será redirecionado para a página "/cadastropessoa".

A expressão .failureUrl("/login?error=true") define a URL para onde o usuário será redirecionado caso ocorra uma falha no login. Se o login não for bem-sucedido, o usuário será 
redirecionado para a página de login novamente, mas com o parâmetro "error=true" adicionado à URL. Isso pode ser útil para exibir uma mensagem de erro ou tomar outras ações com 
base na falha do login.

Em resumo, esse script configura as páginas e URLs associadas ao processo de login. Define a página de login, a página padrão após o login bem-sucedido e a página de 
redirecionamento em caso de falha no login. Essas configurações podem ser personalizadas de acordo com os requisitos específicos da aplicação.

-------------- // ---------------

A expressão .and().logout() indica que uma configuração para o logout está sendo adicionada à configuração existente.

A expressão .logoutSuccessUrl("/login") define a URL para onde o usuário será redirecionado após fazer logout com sucesso. Quando o usuário realiza o logout, ele é redirecionado 
para a página de login, que nesse caso é "/login".

Essa configuração garante que, após o logout bem-sucedido, o usuário seja redirecionado para a página de login, permitindo que ele faça login novamente ou execute outras ações 
apropriadas.

Em resumo, esse script configura a URL de redirecionamento após o logout. Após o logout bem-sucedido, o usuário será redirecionado para a página de login especificada ("/login"). 
Essa configuração pode ser personalizada de acordo com as necessidades da aplicação.

-------------- // ---------------

A expressão `.logoutRequestMatcher(new AntPathRequestMatcher("/logout"))` configura a URL ("/logout") na qual o processo de logout será acionado. Isso indica que quando uma 
requisição com a URL "/logout" for recebida, o Spring Security irá processar o logout do usuário.

O uso da classe `AntPathRequestMatcher` permite especificar um padrão de URL usando padrões de correspondência Ant. No caso desse script, estamos configurando o padrão "/logout", 
o que significa que qualquer requisição com essa URL irá acionar o processo de logout.

Essa configuração é útil para personalizar a URL de logout e pode ser usada quando a URL padrão fornecida pelo Spring Security não atende aos requisitos específicos da aplicação.

Em resumo, esse script configura a URL de logout para "/logout". Quando uma requisição com essa URL for recebida, o Spring Security irá processar o logout do usuário. Essa 
configuração pode ser personalizada de acordo com as necessidades da aplicação.


-------------- // ---------------


OBS. Tive que modificar o CDN do Materialize CSS, pois estava gerando erro. configurar o CDN direto - Usando o link externo:
Site: https://materializecss.com/getting-started.html

<!-- MATERIALIZE -->
<!--Import Google Icon Font-->
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

<!-- Compiled and minified CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">

<!-- Compiled and minified JavaScript -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

<!--Let browser know website is optimized for mobile-->
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

-------------------------------------------------------------- // ---------------------------------------------------------------
Consumindo Web Service RESTful CEP

Links:
https://viacep.com.br/
https://viacep.com.br/ws/01001000/json/

Adicionando o JQuey - No link vamos copiar a codificação do javascript e do html no projeto.
https://viacep.com.br/exemplo/jquery/


-------------------------------------------------------------- // ---------------------------------------------------------------

Para passar um parametro de pesquisa vamos utilizar a propriedade 'name' com o valor 'sexopesquisa' dentro do select do Sexo.

-------------------------------------------------------------- // ---------------------------------------------------------------

Vamos utilizar o software TIBCO JasperSoft para criar um relatorio das pessoas. Mas antes vamos fazer um jar do projeto. 
Com o botão direito em cima da pasta src/main/java > Export > JAR file > next > Browser (seleciona o lugar para salvar o jar do projeto) > nomeia o jar 'jar-projeto-spring-boot' >
next > next > finish.

No JasperSoft vamos criar o projeto - file > new > Jasper Report > next > Escolher o Formato de relatorio (Blank A4) > 
next > File name (esse arquivo é o código fonte do nosso relatório) - nomear de 'pessoa.jrxml' > next > 
Data Adapter (fonte de dados) clica em 'new' escolhe a opção 'collection of javabeans' (no caso, são as classes java) > next >
'name' coloca "Coleção de objetos projeto spring boot thymeleaf" | depois temos que fazer encontrar a Classe Pessoa, no caso vamos em 'Add' e adicionar o jar 'jar-projeto-spring-boot' |
onde está 'The static method in the Factory that returns a Collection<?> or an array of objects' deixa o campo em branco | 
onde está 'Factory class (the class that will produce java beans)' coloca todo o nome do pacote de modelo Pessoa 'projeto.springboot.model.Pessoa' > Finish > next > Finish

Depois de criado o projeto no jaspersoft vamos fazer um 'Compile Report' para verificar se ao compilar corretamente e e em 'Dataset and Query Dialog' na opção 'Coleção de objeto' escolhe a 
opção 'Coleção de objetos projeto spring boot thymeleaf' | depois na aba 'Java Bean' em 'Class name' clica nos três pontinhos (...) pesquisa pela nossa classe Pessoa (se não encontrar faremos o seguinte).

Para encontrar a nossa classe Pessoa vamos em: Vamos com o botão direito em cima do projeto 'MyReports'(esse é o nome do projeto criado para o jaspersoft) > properties > 
java build path > aba libraries (em Modulepath) > add External JARS... (add o jar que foi salvo do projeto) > apply > apply and close. 

Agora podemos ir de novo em 'Dataset and Query Dialog' em 'Java Bean' em 'Class name' clica nos três pontinhos (...) pesquisa pela nossa classe Pessoa e quando aparecer clica nela. 
Ao clicar nela automaticamente irá mostrar todas as propriedades dessa Classe Pessoa e vamos sublinhar apenas as propriedades que serão utilizadas e clica em 'add select fields' > ok.

Basta criar o relatorio com as propriedades que deseja colocar. Depois de ter feito o relátorio temos que copiar os arquivos dentro do projeto jaspersoft. Para isso
podemos ir em properties e clicar no caminho da pasta do projeto, nessa pasta vai ser criado dois arquivos 'pessoa.jasper' e 'pessoa.jrxml'. Vamos copiar esses arquivos e colar 
na pasta relatorios do projeto springboot.

------------ // ---------------

A classe `JRBeanCollectionDataSource` faz parte da biblioteca JasperReports e é usada para criar uma fonte de dados a partir de uma coleção de objetos Java para ser usada na 
geração de relatórios usando o JasperReports.

Essa classe é útil quando você deseja criar relatórios em que os dados são originados de uma coleção de objetos Java, como uma lista de objetos. Cada objeto na coleção 
representa um registro de dados no relatório.

A seguir estão alguns conceitos importantes relacionados à classe `JRBeanCollectionDataSource`:

1. Fonte de dados: A classe `JRBeanCollectionDataSource` atua como uma fonte de dados para o relatório. Ela converte a coleção de objetos Java em uma estrutura que o 
JasperReports pode entender e processar para gerar o relatório.

2. Coleção de objetos Java: A fonte de dados `JRBeanCollectionDataSource` aceita uma coleção de objetos Java, como uma lista, um conjunto ou uma matriz. Cada objeto da coleção 
representa um registro de dados no relatório.

3. Campos de dados: Cada propriedade do objeto Java na coleção é considerada como um campo de dados no relatório. Por exemplo, se a coleção contém objetos do tipo `Pessoa`, onde 
cada objeto tem propriedades como "nome", "idade" e "endereço", essas propriedades serão tratadas como campos de dados no relatório.

4. Uso no JasperReports: Uma vez criada a fonte de dados `JRBeanCollectionDataSource`, você pode passá-la para o gerador de relatórios do JasperReports, que irá processar a 
fonte de dados e preencher o relatório com os dados da coleção.

Dessa forma, a classe `JRBeanCollectionDataSource` é uma maneira eficiente e conveniente de usar coleções de objetos Java como fonte de dados para gerar relatórios usando o 
JasperReports.

------------ // ---------------

A classe File faz parte do pacote java.io em Java e é usada para representar e manipular informações sobre arquivos e diretórios no sistema de arquivos do computador. Essa 
classe fornece métodos para criar, ler, gravar, renomear, excluir e obter informações sobre arquivos e diretórios.

Principais características e funcionalidades da classe File:

Representação de arquivos e diretórios: A classe File pode representar tanto arquivos quanto diretórios no sistema de arquivos. Isso significa que você pode criar objetos File 
para arquivos específicos e para diretórios que contêm outros arquivos.

Manipulação de arquivos: A classe File permite criar novos arquivos, gravar dados em arquivos existentes, ler dados de arquivos e excluir arquivos.

Manipulação de diretórios: Você pode criar novos diretórios, listar o conteúdo de um diretório, verificar se um caminho representa um diretório ou arquivo e excluir diretórios.

Caminhos de arquivos: A classe File aceita caminhos de arquivos como argumento em seus construtores e métodos. Os caminhos podem ser absolutos (começando na raiz do sistema 
de 
arquivos) ou relativos (relativos ao diretório atual).

Verificação de existência e permissões: A classe File fornece métodos para verificar se um arquivo ou diretório existe, se é acessível e se você tem permissão para ler ou 
gravar nele.

Manipulação de metadados: A classe File permite obter informações sobre arquivos e diretórios, como tamanho, data de modificação, permissões, caminho absoluto e muito mais.

Em resumo, a classe File é uma ferramenta essencial para trabalhar com arquivos e diretórios em Java e oferece uma variedade de métodos para manipular, acessar e obter 
informações sobre eles.

------------ // ---------------

A classe JasperPrint faz parte da biblioteca JasperReports e representa o resultado gerado após o preenchimento de um modelo de relatório (template) com dados. Essa classe 
contém as informações necessárias para renderizar o relatório em diferentes formatos, como PDF, HTML, XLS (Excel), entre outros.

Principais características e funcionalidades da classe JasperPrint:

Representação do relatório preenchido: A classe JasperPrint armazena o resultado do preenchimento de um modelo de relatório (arquivo .jasper) com os dados fornecidos. Isso 
inclui a estrutura do relatório, seus elementos visuais e os dados substituídos nos campos do relatório.

Geração de relatórios: Após o preenchimento bem-sucedido do modelo de relatório com os dados, um objeto JasperPrint é criado, permitindo a geração do relatório em diferentes 
formatos.

Formatos de saída: A classe JasperPrint pode ser usada para renderizar o relatório em vários formatos de saída, como PDF, HTML, XLS (Excel), CSV, XML, entre outros. Isso 
permite que o mesmo conteúdo do relatório seja exibido ou exportado em diferentes tipos de arquivos.

Páginas do relatório: O objeto JasperPrint pode conter várias páginas de relatório, caso o relatório seja paginado. Cada página representa uma visualização diferente do mesmo 
relatório, que pode conter diferentes dados ou parâmetros.

Exportação do relatório: O objeto JasperPrint pode ser usado para exportar o relatório em um formato específico usando os recursos do JasperReports.

Em resumo, a classe JasperPrint é uma parte crucial do JasperReports, pois representa o relatório preenchido e permite sua renderização e exportação em vários formatos para 
exibição ou armazenamento.

------------ // ---------------

A classe JasperFillManager faz parte da biblioteca JasperReports e é responsável por preencher um modelo de relatório (template) com dados para criar um objeto JasperPrint, que 
representa o relatório preenchido e pronto para ser renderizado ou exportado em diferentes formatos.

Principais características e funcionalidades da classe JasperFillManager:

Preenchimento de relatórios: A principal função da classe JasperFillManager é preencher um modelo de relatório com dados, criando assim um objeto JasperPrint que representa o 
relatório preenchido.

Parâmetros: Além dos dados a serem exibidos no relatório, você pode passar parâmetros adicionais para o modelo de relatório por meio do JasperFillManager. Os parâmetros podem 
ser usados no template para personalizar o relatório ou fornecer informações adicionais.

Fontes de dados: Para preencher o relatório, você precisa fornecer uma fonte de dados apropriada, geralmente representada por uma implementação da classe JRDataSource. A 
biblioteca JasperReports oferece várias implementações prontas para uso, como JRBeanCollectionDataSource para trabalhar com coleções de objetos Java, e também permite criar 
fontes de dados personalizadas, se necessário.

Formato do relatório: O resultado do preenchimento do modelo de relatório é um objeto JasperPrint, que contém as informações necessárias para renderizar ou exportar o relatório 
em vários formatos, como PDF, HTML, XLS (Excel) e outros.

Em resumo, a classe JasperFillManager é usada para preencher modelos de relatórios com dados e criar objetos JasperPrint, que são essenciais para a geração e manipulação de 
relatórios usando a biblioteca JasperReports.

O método fillReport é um dos principais métodos da classe JasperFillManager na biblioteca JasperReports. Ele é responsável por preencher um modelo de relatório (template) com 
dados e produzir um objeto JasperPrint, que representa o relatório preenchido e pronto para ser exibido ou exportado em diferentes formatos.

Assinatura do método fillReport

```
public static JasperPrint fillReport(JasperReport jasperReport, Map<String, Object> parameters, JRDataSource dataSource) throws JRException;
```

Parâmetros:

 -> jasperReport: O modelo de relatório compilado (arquivo .jasper) do tipo JasperReport.
 -> parameters: Um mapa contendo os parâmetros que serão passados para o relatório (opcional). Os parâmetros são usados para personalizar o relatório ou fornecer informações 
                adicionais.
 -> dataSource: A fonte de dados que contém os dados a serem exibidos no relatório, representada por uma implementação de JRDataSource. Essa fonte de dados pode ser uma lista 
                de objetos Java, um conjunto de resultados de banco de dados, ou qualquer outra implementação personalizada.
                
Funcionamento:

-> O método fillReport recebe o modelo de relatório compilado (jasperReport) e uma fonte de dados (dataSource) contendo os dados a serem exibidos no relatório.
-> Se houver parâmetros a serem passados para o relatório, eles são fornecidos através do mapa parameters.
-> O modelo de relatório é preenchido com os dados e parâmetros fornecidos, resultando em um objeto JasperPrint que representa o relatório preenchido.

------------ // ---------------

A classe JasperExportManager faz parte da biblioteca JasperReports e é responsável por exportar um objeto JasperPrint, que representa um relatório preenchido, para diferentes 
formatos de saída, como PDF, HTML, XLS (Excel), entre outros. Essa classe oferece métodos estáticos para realizar as operações de exportação de forma simples e direta.

Principais características e funcionalidades da classe JasperExportManager:

Exportação de relatórios: A principal função da classe JasperExportManager é exportar um objeto JasperPrint para um formato de arquivo específico, conforme necessário.

Formatos de saída suportados: A classe oferece suporte para exportar relatórios nos formatos mais comuns, como PDF, HTML, XLS (Excel), CSV, XML, RTF, entre outros. Isso permite 
que os relatórios sejam visualizados ou compartilhados em diferentes tipos de arquivos.

Configurações adicionais: Em alguns formatos de saída, você pode definir configurações adicionais durante a exportação, como tamanho de página, orientação, fontes, cores, 
entre outros. Essas configurações podem ser especificadas por meio de parâmetros extras ao chamar os métodos de exportação.

------------ // ---------------
Explicando a Classe ReportUtil:

Ela responsável por gerar relatórios em formato PDF a partir de um arquivo JasperReports pré-compilado (arquivo .jasper) e uma lista de dados fornecida como entrada. Essa 
classe utiliza a biblioteca JasperReports para criar e exportar os relatórios.

Aqui está uma explicação detalhada das principais partes do script:

1. Anotação `@Component`: Essa anotação indica que a classe `ReportUtil` é um componente gerenciado pelo Spring e pode ser injetada em outras classes usando a injeção de 
                          dependência do Spring.

2. Método `geraRelatorio`: Este método é responsável por gerar o relatório em formato PDF. Ele recebe três parâmetros:
   - `listaDados`: Uma lista contendo os dados que serão exibidos no relatório. Essa lista é utilizada para preencher o modelo de relatório.
   
   - `relatorio`: O nome do arquivo JasperReports pré-compilado (sem a extensão .jasper) que será utilizado para gerar o relatório. O arquivo deve estar localizado na pasta 
                  "relatorios" do projeto.
                  
   - `servletContext`: Uma instância do objeto `ServletContext` que permite acessar informações sobre o contexto do servlet, incluindo a localização de recursos no sistema de 
                       arquivos.

3. `JRBeanCollectionDataSource`: Essa classe é utilizada para criar uma fonte de dados a partir de uma lista de objetos Java (`listaDados`). A classe `JRBeanCollectionDataSource` 
                                 é uma implementação da interface `JRDataSource` que permite preencher o modelo de relatório com os dados da lista.

4. `JasperFillManager.fillReport`: Este método é usado para preencher o modelo de relatório (arquivo .jasper) com os dados fornecidos pela fonte de dados (`jrbcds`). O resultado 
                                   do preenchimento é um objeto `JasperPrint`, que representa o relatório preenchido e pronto para ser exportado.

5. `JasperExportManager.exportReportToPdf`: Este método é responsável por exportar o relatório preenchido (representado pelo objeto `JasperPrint`) para um arquivo PDF. O método 
                                            retorna um array de bytes (byte[]) contendo o conteúdo do relatório PDF.

Portanto, a classe `ReportUtil` encapsula a lógica para gerar relatórios PDF a partir de arquivos JasperReports e listas de dados. Essa classe pode ser utilizada em um projeto 
Spring para gerar relatórios dinâmicos com base em dados fornecidos pela aplicação. Ela simplifica a criação de relatórios e a exportação para PDF, facilitando a geração de 
documentos impressos para os usuários da aplicação.

------------ // ---------------

Vale ressaltar que para gerar o PDF não pode redirecionar a página, senão ele irá perder o download. Ou seja, terei que enviar os dados (get) sem recarregar a tela.
No botão 'PDF' vamos fazer que ao clicar se torne de post para o método get. O método get só irá funcionar ao clicar no botão PDF e depois ele irá retornar a ser
post novamente. Vamos utilizar o javascript para isso.

<input type="submit" value="PDF" onclick="document.getElementById('pesquisarpessoa').method = 'get'" class="waves-effect waves-light btn">
					