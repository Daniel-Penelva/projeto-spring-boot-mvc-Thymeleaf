Acessar a aplicação: 
http://localhost:8080/
http://localhost:8080/cadastropessoa
   
   < ARQUITETURA MVC - FUNCIONAMENTO > 
                                  
                                                                                                   |-----------------------------------------------
 Tela/ Cliente/ Sistema                                                                            |         JAVA/ SPRING MVC/ SERVLET            |
    _______                                                                                        |                                              |
   |       |                                                                                       |                                              |
   |       |                requisição /POST/GET                                                   |   CONTROLLER                BANCO DE DADOS   |
   |       | ------------------------------------------------------------------------------------->| |------------|              |------------|   |
   |       |                                                                                       | | validações |              |    dados   |   |
   |       | RESPOSTA compilada com o HTML para o navegador interpretar                            | |            |              |            |   |
   |_______| <-------------------------------------------------------------------------------------| |____________|              |____________|   |
                                                                                                   |                                              |
   Front-End                                                                                       |    ^    |                      ^      |      |
    (HTML)                                                                                         |    |    |                      |      |      |
  (Javascript)                                                                                     |    |    v                      |      v      |
                                                                                                   |                                              |
                                                                                                   |   SERVICE                    DAO/REPOSITORY  |
                                                                                                   | |----------|                 |-----------|   |
                                                                                                   | | Regra de | --------------> | SQL/JPA   |   |
                                                                                                   | | negócio  | <-------------- |           |   |
                                                                                                   | |__________|                 |___________|   |
                                                                                                   |______________________________________________|

A arquitetura MVC (Model-View-Controller) é um padrão de arquitetura de software amplamente utilizado para o desenvolvimento de aplicativos. Ele separa a lógica de 
negócios, a apresentação dos dados e a interação com o usuário em três componentes distintos: Model, View e Controller. Cada componente possui responsabilidades 
específicas e se comunica com os outros componentes de forma estruturada. Vamos entender como cada componente funciona:

1. Model:
O Model representa a camada de dados e lógica de negócios. Ele encapsula o estado e o comportamento dos dados da aplicação. Essa camada é responsável por acessar e 
manipular os dados, bem como aplicar as regras de negócio. O Model geralmente consiste em classes como entidades, serviços, repositórios, APIs, etc.

2. View:
A View é responsável pela apresentação dos dados ao usuário. Ela exibe a interface do usuário, como páginas HTML, telas, formulários, gráficos, entre outros elementos 
visuais. A View recebe dados do Model para exibi-los e também envia informações do usuário para o Controller. Geralmente, as Views são implementadas usando tecnologias 
como HTML, CSS, JavaScript, JSP, Thymeleaf, entre outras.

3. Controller:
O Controller é responsável por receber as requisições do usuário, processá-las e coordenar as ações apropriadas. Ele atua como intermediário entre a View e o Model. 
O Controller é responsável por receber os dados da View, interagir com o Model para executar ações necessárias, como buscar dados, atualizar informações, executar 
lógica de negócio, etc., e então retornar os resultados para a View. Normalmente, os Controllers são implementados como classes ou métodos em frameworks web, como 
Spring MVC, ASP.NET MVC, Django, entre outros.

No contexto da arquitetura MVC, o Service (ou Service Layer) é responsável por abrigar a lógica de negócio da aplicação. Ele atua como uma camada intermediária entre 
o Controller e o Model, encapsulando as regras e operações complexas relacionadas ao domínio do problema. O Service é uma prática comum em muitas implementações de MVC
e tem como objetivo principal separar a lógica de negócio do Controller e do Model, mantendo assim a responsabilidade de cada camada de forma clara e modular.

No contexto da arquitetura MVC, o DAO (Data Access Object) ou Repository é responsável por encapsular a interação com o banco de dados e fornecer métodos para realizar 
operações de persistência e recuperação de dados. O DAO/Repository atua como uma camada de abstração entre o Model e o banco de dados, permitindo que o restante da 
aplicação trabalhe com objetos do Model sem se preocupar com detalhes específicos de acesso aos dados. Em resumo, o DAO/Repository na estrutura MVC é responsável por 
encapsular a lógica de acesso aos dados do banco de dados, fornecendo métodos para realizar operações de persistência e recuperação de dados. Ele abstrai os detalhes 
de acesso ao banco de dados, permite consultas customizadas e promove a testabilidade das operações de dados.

O fluxo básico de funcionamento da arquitetura MVC é o seguinte:

1. O usuário interage com a View, como preenchendo um formulário ou clicando em um botão.
2. A View captura as interações do usuário e envia uma requisição para o Controller correspondente.
3. O Controller recebe a requisição, processa-a e interage com o Model, se necessário, para executar as ações apropriadas.
4. O Model executa as operações de manipulação de dados e lógica de negócio necessárias.
5. O Controller recebe os resultados do Model e seleciona a View adequada para renderizar os dados.
6. A View recebe os dados do Controller e os apresenta ao usuário de forma adequada.
7. O usuário visualiza os resultados na View e, se necessário, inicia uma nova interação.

Essa separação de responsabilidades facilita a manutenção, a reutilização de código e o desenvolvimento colaborativo, uma vez que cada componente possui uma função 
claramente definida. Além disso, a arquitetura MVC permite uma maior flexibilidade, pois é possível alterar a View ou o Model independentemente um do outro, desde que 
a interface entre eles seja mantida.

Vale ressaltar que existem variações e adaptações do padrão MVC, como o MVVM (Model-View-ViewModel) e o MVP (Model-View-Presenter), que incorporam diferentes abordagens 
para atender a necessidades específicas de diferentes frameworks e tecnologias. No entanto, a ideia fundamental de separação de responsabilidades entre Model, View e 
Controller permanece como base em várias arquiteturas de software.

--------------------------------------------------------------------------------------------------- // --------------------------------------------------------------------------

Bom Saber:

A propriedade "spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults" é uma configuração específica do Hibernate, um framework de mapeamento objeto-relacional para Java, 
quando usado em conjunto com o Spring Framework.

Essa propriedade determina se o Hibernate deve usar os metadados padrão do JDBC (Java Database Connectivity) ao criar tabelas temporárias durante a execução de consultas. Quando 
definida como "false", o Hibernate irá desabilitar o uso dos metadados padrão do JDBC e, em vez disso, irá usar seus próprios metadados para a criação das tabelas temporárias.

Essa configuração pode ser útil em certos casos em que o comportamento padrão do Hibernate com relação às tabelas temporárias não atende aos requisitos específicos do aplicativo. 
Ao desabilitar o uso dos metadados padrão do JDBC, você pode ter um controle mais preciso sobre a criação e configuração dessas tabelas temporárias.

É importante destacar que essa é apenas uma das várias propriedades de configuração disponíveis no Hibernate e no Spring Framework, e seu efeito exato dependerá do contexto em 
que está sendo utilizada, assim como das outras configurações do aplicativo. Recomenda-se consultar a documentação oficial do Hibernate e do Spring Framework para obter informações 
mais detalhadas sobre o uso dessa propriedade e outras configurações relacionadas.

------------- // -------------

A propriedade "spring.jpa.properties.hibernate.dialect" é utilizada para configurar o dialeto (dialect) do Hibernate ao trabalhar com um banco de dados específico. Neste caso em 
particular, o valor definido para a propriedade é "org.hibernate.dialect.PostgreSQLDialect", indicando que o Hibernate deve utilizar o dialeto do PostgreSQL.

O dialeto do Hibernate é responsável por fornecer as instruções SQL específicas do banco de dados que estão sendo utilizadas. Cada banco de dados possui suas próprias particularidades 
e diferenças na sintaxe e recursos SQL. Portanto, é necessário configurar corretamente o dialeto do Hibernate para que ele possa gerar as consultas SQL adequadas e compatíveis 
com o banco de dados em uso.

Ao definir "org.hibernate.dialect.PostgreSQLDialect" como o valor dessa propriedade, o Hibernate irá gerar as consultas SQL específicas para o PostgreSQL. O dialeto do PostgreSQL 
é otimizado para trabalhar com esse banco de dados em particular, aproveitando os recursos e as funcionalidades específicas oferecidas pelo PostgreSQL.

É importante observar que o Hibernate oferece uma variedade de dialetos para diferentes bancos de dados, e a escolha correta do dialeto a ser usado depende do banco de dados que 
está sendo utilizado em sua aplicação. Se você estiver usando um banco de dados diferente do PostgreSQL, será necessário fornecer o dialeto apropriado correspondente ao seu banco 
de dados específico.

------------- // -------------

A anotação `@ComponentScan` é uma anotação do Spring Framework que é usada para especificar os pacotes base a serem verificados em busca de componentes gerenciados pelo Spring, 
como classes anotadas com `@Component`, `@Service`, `@Repository` ou `@Controller`.

A anotação `@ComponentScan` é usada em conjunto com a anotação `@Configuration` ou `@SpringBootApplication` para definir a configuração do contexto do Spring e permitir que o 
Spring encontre automaticamente e registre os componentes dentro dos pacotes especificados.

No exemplo dado, a anotação `@ComponentScan(basePackages = {"projeto.*"})` está configurada para escanear os pacotes que possuem o prefixo "projeto.". Isso significa que o Spring 
irá percorrer esses pacotes em busca de classes anotadas com `@Component`, `@Service`, `@Repository` ou `@Controller` para serem registradas como beans gerenciados pelo Spring.

Essa anotação é útil quando você possui componentes personalizados que precisam ser reconhecidos e gerenciados pelo Spring, permitindo que você aproveite a injeção de dependência, 
a configuração automática e outros recursos do Spring Framework.

Você pode ajustar os pacotes especificados no array `basePackages` para corresponder aos pacotes relevantes do seu projeto. Além disso, você também pode usar outras opções, como 
`basePackageClasses` para especificar as classes base ou `value` como um alias para `basePackages`.

Em resumo, a anotação `@ComponentScan` permite ao Spring encontrar automaticamente componentes em pacotes específicos e registrá-los como beans gerenciados pelo Spring. Isso 
facilita o desenvolvimento e configuração de aplicativos Spring, pois você não precisa registrar manualmente cada componente individualmente.

------------- // -------------

A anotação `@Repository` é uma anotação do Spring Framework que é usada para indicar que uma classe é responsável por acessar e manipular dados persistentes, geralmente em um 
banco de dados. 

A anotação `@Repository` é uma especialização da anotação `@Component`, o que significa que uma classe anotada com `@Repository` será tratada como um componente pelo Spring e 
será elegível para injeção de dependência e outras funcionalidades fornecidas pelo Spring.

O propósito principal da anotação `@Repository` é fornecer um meio para categorizar e identificar classes que atuam como repositórios de dados. Esses repositórios são responsáveis 
por fornecer uma abstração para o acesso a dados persistentes, encapsulando detalhes específicos do armazenamento de dados, como consultas SQL ou interações com o banco de dados.

Ao usar a anotação `@Repository`, você permite que o Spring realize a injeção de dependência automaticamente em outras classes que dependem desse repositório. Além disso, a 
anotação `@Repository` também oferece recursos adicionais, como a tradução automática de exceções específicas do banco de dados para exceções de persistência do Spring.

Embora o uso da anotação `@Repository` seja opcional, é uma prática comum aplicá-la a classes que atuam como repositórios de dados, pois ela ajuda na organização e semântica do 
código, além de fornecer recursos adicionais fornecidos pelo Spring.

É importante observar que a anotação `@Repository` faz parte do contexto do Spring Data, que é uma subestrutura do Spring Framework que fornece abstrações e recursos adicionais 
para acesso a dados. Portanto, seu uso é frequentemente associado ao Spring Data JPA, Spring Data JDBC, Spring Data MongoDB e outras implementações do Spring Data.

Em resumo, a anotação `@Repository` é usada para marcar uma classe como um repositório de dados, permitindo que o Spring a gerencie como um componente e forneça recursos 
adicionais para acesso a dados persistentes.

------------- // -------------

A anotação `@Transactional` é uma anotação do Spring Framework que é usada para indicar que um método ou classe deve ser executado dentro de um contexto transacional. 

Quando um método é anotado com `@Transactional`, o Spring cuida da criação e gerenciamento de uma transação para esse método. Transações são utilizadas para garantir a atomicidade, 
consistência, isolamento e durabilidade (ACID) das operações em um banco de dados ou outro recurso transacional.

A anotação `@Transactional` pode ser aplicada a um método específico ou a toda uma classe. Quando aplicada a um método específico, somente esse método será executado em uma 
transação. Se aplicada a uma classe, todos os métodos dentro dessa classe serão executados em uma transação.

Ao utilizar a anotação `@Transactional`, você pode obter vários benefícios:

1. Gerenciamento automático de transações: O Spring cuida da criação, commit e rollback de transações, tornando o código mais simples e livre de preocupações com o controle manual 
   de transações.

2. Suporte a várias estratégias de transação: O Spring suporta várias estratégias de transação, como transações baseadas em anotações, transações programáticas e transações 
   declarativas baseadas em XML. Você pode configurar a estratégia de transação adequada para suas necessidades.

3. Controle de isolamento e propagação da transação: A anotação `@Transactional` permite que você especifique o nível de isolamento da transação e a propagação para outros métodos 
   chamados. Isso garante a consistência e o comportamento esperado das transações em diferentes cenários.

4. Tratamento de exceções e rollback: O Spring trata exceções lançadas dentro de um método transacional e realiza o rollback da transação em caso de exceção não tratada. Isso 
   garante que as operações sejam revertidas adequadamente em caso de falhas.

É importante ressaltar que a anotação `@Transactional` deve ser usada com cuidado e em conjunto com um mecanismo de gerenciamento de transações adequado, como o Spring 
Transaction Management. Além disso, é importante considerar os detalhes de configuração e a configuração do ambiente para garantir o comportamento desejado das transações.

Em resumo, a anotação `@Transactional` é usada para marcar métodos ou classes que devem ser executados dentro de um contexto transacional, permitindo que o Spring gerencie 
automaticamente as transações e forneça recursos avançados, como controle de isolamento, propagação, tratamento de exceções e rollback.

------------- // -------------

A classe `CrudRepository<T, ID>` faz parte do Spring Data e é uma interface genérica fornecida pelo Spring Framework para facilitar a criação de repositórios de acesso a dados.

Vamos analisar cada um dos parâmetros utilizados na classe `CrudRepository<Pessoa, Long>`:

1. `T` é o tipo de entidade (modelo de dados) com o qual o repositório está lidando. No exemplo dado, `Pessoa` é o tipo da entidade que o repositório manipulará. Você substituirá 
   `Pessoa` pelo nome da sua entidade.

2. `ID` é o tipo do identificador único da entidade. O `ID` pode ser um tipo primitivo, como `Long`, `Integer`, `String`, ou um tipo personalizado. No exemplo dado, o identificador 
   único da entidade `Pessoa` é do tipo `Long`. Mais uma vez, você substituirá `Long` pelo tipo adequado do identificador da sua entidade.

A classe `CrudRepository` fornece um conjunto de métodos prontos para uso para realizar operações CRUD (Create, Read, Update, Delete) no banco de dados. Alguns dos métodos mais 
comuns fornecidos pela `CrudRepository` incluem:

- 'save(entity)': Salva ou atualiza uma entidade no banco de dados.
- 'findById(id)': Recupera uma entidade pelo seu identificador único.
- 'findAll()': Recupera todas as entidades do tipo especificado.
- 'delete(entity)': Exclui uma entidade do banco de dados.
- 'count()': Retorna o número total de entidades no repositório.

Esses métodos e outros estão disponíveis na classe `CrudRepository`, permitindo que você execute operações básicas de CRUD sem a necessidade de escrever código repetitivo. No 
entanto, a `CrudRepository` é uma interface genérica e precisa ser estendida por uma interface personalizada ou uma classe concreta para ser utilizada.

Ao estender a `CrudRepository`, você pode adicionar métodos personalizados para atender às necessidades específicas do seu domínio, se necessário.

Por exemplo, se você estender a `CrudRepository<Pessoa, Long>` com uma interface chamada `PessoaRepository`, você poderá utilizar métodos herdados, como `findById`, `save`, 
`findAll`, etc., além de adicionar métodos personalizados, como `findByNome` ou `findByEmail`.

Em resumo, a classe `CrudRepository` é uma interface genérica do Spring Data que fornece operações básicas de CRUD para acesso a dados. Você pode estender essa interface e 
personalizá-la para manipular entidades específicas do seu domínio no banco de dados.

------------- // -------------

A anotação `@EnableJpaRepositories` é uma anotação do Spring Framework que é usada para habilitar os recursos de repositórios JPA (Java Persistence API) fornecidos pelo Spring 
Data JPA.

Essa anotação é tipicamente usada em uma classe de configuração do Spring, geralmente uma classe anotada com `@Configuration` ou uma classe de inicialização do aplicativo anotada 
com `@SpringBootApplication`.

Ao utilizar a anotação `@EnableJpaRepositories`, você está ativando a funcionalidade de repositórios JPA do Spring Data para o projeto. A anotação permite que você defina as 
configurações para os repositórios JPA, como a localização dos repositórios e outras opções de configuração.

A opção `basePackages` é usada para especificar o pacote (ou pacotes) onde os repositórios JPA estão localizados. No exemplo dado, `projeto.springboot.repository` é o pacote base 
onde os repositórios JPA estão localizados. Isso indica ao Spring Data JPA onde procurar por interfaces de repositório para implementação automática.

Ao definir o pacote base através da opção `basePackages`, o Spring Data JPA irá escanear esse pacote e seus subpacotes em busca de interfaces de repositório anotadas com 
`@Repository` ou outras anotações específicas do Spring Data JPA.

Uma vez que as interfaces de repositório são encontradas, o Spring Data JPA irá gerar automaticamente a implementação dessas interfaces em tempo de execução, fornecendo assim a 
funcionalidade de acesso a dados para as entidades correspondentes.

É importante mencionar que a anotação `@EnableJpaRepositories` também oferece outras opções de configuração, como `entityManagerFactoryRef`, `transactionManagerRef` e 
`repositoryImplementationPostfix`, que permitem personalizar ainda mais o comportamento dos repositórios JPA.

Em resumo, a anotação `@EnableJpaRepositories` é usada para habilitar a funcionalidade de repositórios JPA do Spring Data. Através dessa anotação, você pode especificar o pacote 
base onde os repositórios JPA estão localizados, permitindo que o Spring Data JPA os encontre, gere as implementações automaticamente e forneça acesso a dados para suas entidades.


------------- // -------------

A anotação `@EnableTransactionManagement` é uma anotação do Spring Framework que é usada para habilitar o suporte a transações em um aplicativo Spring.

Ao utilizar a anotação `@EnableTransactionManagement`, você está ativando o suporte a transações do Spring Framework, permitindo que você utilize transações declarativas no seu 
código.

Essa anotação é tipicamente usada em uma classe de configuração do Spring, geralmente uma classe anotada com `@Configuration` ou uma classe de inicialização do aplicativo anotada 
com `@SpringBootApplication`.

Ao habilitar o suporte a transações com `@EnableTransactionManagement`, você pode usar anotações como `@Transactional` em métodos de negócio ou serviços para indicar que eles 
devem ser executados dentro de uma transação.

A anotação `@Transactional` é responsável por iniciar, gerenciar e finalizar transações automaticamente para os métodos anotados. Quando um método anotado com `@Transactional` é 
chamado, uma transação é criada e o contexto da transação é definido. O Spring gerencia automaticamente o início e o fim da transação, além de lidar com o commit ou rollback da 
transação, dependendo do resultado do método.

Além disso, a anotação `@EnableTransactionManagement` também permite que você configure um gerenciador de transações personalizado, como um `PlatformTransactionManager`, para 
controlar o comportamento das transações.

Ao habilitar o suporte a transações, você pode alcançar os seguintes benefícios:

- Atomicidade: As transações são executadas como uma unidade indivisível, onde todas as operações são confirmadas ou revertidas em conjunto.
- Consistência: As transações garantem que os dados estejam em um estado consistente antes e após sua execução.
- Isolamento: As transações oferecem isolamento, permitindo que elas sejam executadas independentemente de outras transações em andamento.
- Durabilidade: As transações confirmadas são permanentes e não serão perdidas mesmo em caso de falhas ou reinicialização do sistema.

Em resumo, a anotação `@EnableTransactionManagement` é usada para habilitar o suporte a transações no Spring Framework. Isso permite que você utilize a anotação `@Transactional` 
para marcar métodos que devem ser executados em uma transação, facilitando o gerenciamento e a consistência dos dados no seu aplicativo.

------------- // -------------

<tr th:each="pessoa : ${pessoas}">

Essa propriedade "${pessoas}" vai vir do banco de dados.
A propriedade "pessoa" é o que vai ser mostrado na tela.

------------- // -------------


A classe ModelAndView é uma classe do Spring Framework que é usada para encapsular dados do modelo e informações da visualização em um objeto.

A classe ModelAndView é frequentemente utilizada em controladores do Spring MVC para fornecer dados ao modelo e especificar a visualização que será renderizada e retornada ao 
cliente.

A principal finalidade da classe ModelAndView é fornecer uma maneira conveniente de transmitir dados do controlador para a visualização, além de permitir que você especifique a 
visualização que deve ser renderizada.

Ao criar uma instância de ModelAndView, você pode definir o nome da visualização (o nome lógico da visualização configurada em seu aplicativo) e adicionar atributos ao modelo 
(dados que serão utilizados pela visualização para renderizar a resposta).

Ao retornar o objeto ModelAndView no método do controlador, o Spring MVC utilizará o nome da visualização para determinar a visualização que deve ser renderizada. Os atributos do modelo serão disponibilizados para a visualização para que ela possa usar os dados na renderização da resposta.

No exemplo, o Spring MVC procuraria pela visualização chamada "cadastro/cadastropessoa" e a renderizaria usando os dados fornecidos no modelo.

Além disso, a classe ModelAndView também oferece métodos para configurar outras propriedades, como status HTTP, cabeçalhos de resposta e redirecionamentos.

Em resumo, a classe ModelAndView é usada para encapsular dados do modelo e informações da visualização em um objeto no Spring Framework. Ela permite que você especifique o nome 
da visualização e adicione atributos ao modelo, facilitando a passagem de dados do controlador para a visualização.


------------- // -------------

Instalando o Materialize CSS Design - https://materializecss.com/

Vamos baixar o materialize e colocá-lo dentro da pasta "static" projeto. Dentro dessa pasta que fica todos os recursos de css, de imagem e etc...
Site: https://materializecss.com/getting-started.html

Declarar nas páginas os imports (dentro do head):
<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
 
 <!--Import materialize.css - São dois arquivos css -->
<link type="text/css" rel="stylesheet" href="css/materialize.min.css"  media="screen,projection"/>

OBS. Não esquece de renomear o caminho href. Exemplificado abaixo:

<link type="text/css" rel="stylesheet" href="materialize/css/materialize.css"  media="screen,projection"/>
<link type="text/css" rel="stylesheet" href="materialize/css/materialize.min.css"  media="screen,projection"/>


Por fim a declaração do javascript que vai ficar no corpo.
<!--JavaScript at end of body for optimized loading - São dois arquivos css -->-->
<script type="text/javascript" src="js/materialize.min.js"></script>

OBS. Não esquece de renomear o caminho href. Exemplificado abaixo:

<script type="text/javascript" src="materialize/js/materialize.js"></script>
<script type="text/javascript" src="materialize/js/materialize.min.js"></script>

Por exemplo, vamos customizar o botão, podemos copiar a class materialize e colar na tag button. 
https://materializecss.com/buttons.html

Como estava antes:

<label>Nome:</label>
<input name="nome" />
			
<label>Sobrenome:</label>
<input name="sobrenome" />
			
<label>Idade:</label>
<input name="idade" />

------------- // -------------

<td><a th:href="@{/editarpessoa/{idpessoa}(idpessoa=${pessoa.id})}">Editar</a></td>

"idpessoa" é a variavel onde vai ser capturado o id da pessoa. Essa variavel vai ser passada como parametro no método GET no editar para que possamos recuperar os objetos 
(os dados) da pessoa para poder jogar na tela e alterar.

Em tela:
<form action="salvarpessoa" method="post" th:object="${pessoaobj}">

No controller:
modelAndView.addObject("pessoaobj", pessoa.get());

O objetivo em editar a pessoa é buscar os valores da pessoa e jogar na tela, para isso vamos utilizar a propriedade "object" na tag do formulário onde esse objeto vai ser 
carregado através do controller na declaração do nome "objectpessoa". E para conseguir editar esse objeto vai precisar do id na tela e vamos utilizar o thymeleaf para isso, no 
caso, o atributo "field" fará essa função de especificar qual o id está sendo atualizado.

------------- // -------------

Na action do formulario telefone temos que passar a chave da pessoa para poder relacionar o telefone ao determinado código da pessoa. Ou seja, temos que pegar o id da pessoa e
enviar junto com os dados do telefone para que na hora de salvar o novo telefone possa passar para o cadastro de telefone o código da pessoa e ele poder salvar no banco de dados.

------------- // -------------

A anotação `@Valid` e a classe `BindingResult` estão relacionadas à validação de dados em um framework como o Spring MVC. Vou explicar cada um deles:

A anotação `@Valid` é usada para indicar que um objeto deve ser validado de acordo com as regras de validação definidas em sua classe. Ao marcar um parâmetro de método com 
`@Valid`, você está instruindo o framework a executar a validação desse objeto antes de prosseguir com o processamento do método.

Por exemplo, suponha que você tenha uma classe `Pessoa` com campos como nome, idade, email, etc., e tenha definido anotações de validação em alguns desses campos, como 
`@NotNull`, `@NotEmpty`, `@Email`, etc. Ao usar `@Valid` no parâmetro `Pessoa pessoa` do método, você está solicitando ao framework para validar automaticamente os dados dessa 
pessoa com base nas anotações de validação definidas em sua classe.

A classe `BindingResult` é uma classe fornecida pelo framework que contém os resultados da validação. Ela é usada em conjunto com a anotação `@Valid`. Após a validação do objeto 
marcado com `@Valid`, o `BindingResult` é usado para verificar se ocorreram erros de validação e para acessar informações sobre esses erros.

Por exemplo, você pode usar o `BindingResult` para verificar se há erros de validação chamando o método `hasErrors()`. Se houver erros, você pode acessar cada erro individualmente 
usando métodos como `getAllErrors()` para obter uma lista de todos os erros, `getFieldErrors()` para obter apenas os erros de campo específicos ou `getGlobalErrors()` para obter 
erros globais relacionados ao objeto em geral.

O `BindingResult` também fornece métodos para acessar informações adicionais sobre os erros, como as mensagens de erro padrão definidas nas anotações de validação 
(`getDefaultMessage()`), o nome do campo associado a um erro (`getField()`), o valor rejeitado (`getRejectedValue()`), entre outros.

Em resumo, a anotação `@Valid` instrui o framework a validar um objeto com base em suas anotações de validação, enquanto a classe `BindingResult` é usada para obter os resultados 
dessa validação, incluindo informações sobre erros de validação encontrados. 

------------- // -------------

Vale ressaltar que se validar do lado do cliente (utilizando o javascript) não utiliza recurso do servidor, ou seja, gera menos impacto comparado ao que foi validado do lado do 
servidor (controller).

---------------------------------------------------------------------------------- // -------------------------------------------------------------------------------------------

                                                                 < Configurando Spring Security em memória >

A classe `WebSecurityConfigurerAdapter` é uma classe fornecida pelo Spring Security que fornece uma configuração básica para a segurança de aplicativos web. Ela é uma classe 
abstrata que pode ser estendida para personalizar a configuração de segurança do aplicativo.

Ao estender a classe `WebSecurityConfigurerAdapter` e sobrescrever seus métodos, você pode definir as regras de segurança para o seu aplicativo, como autenticação, autorização e 
configurações específicas do protocolo HTTP.

A classe `WebSecurityConfigurerAdapter` possui vários métodos que podem ser sobrescritos para personalizar a configuração de segurança. Alguns dos métodos mais comumente usados 
incluem:

- `configure(AuthenticationManagerBuilder auth)`: permite configurar o mecanismo de autenticação do aplicativo. Você pode definir as fontes de autenticação, como banco de dados, 
                                                  serviço LDAP ou provedor de autenticação personalizado.

- `configure(HttpSecurity http)`: permite configurar as regras de autorização e configurações específicas do protocolo HTTP. Você pode definir quais URLs exigem autenticação, 
                                  quais papéis de usuário têm acesso a determinadas URLs, configurações de sessão, proteção CSRF, CORS e outras configurações de segurança.

- `configure(WebSecurity web)`: permite configurar a segurança para recursos específicos do Spring Security, como o Ignorar configuração para recursos estáticos (CSS, JavaScript, etc.).

- `userDetailsService()`: retorna uma instância de `UserDetailsService`, que pode ser usada para personalizar a autenticação baseada em banco de dados ou outras fontes de dados.

Ao estender a classe `WebSecurityConfigurerAdapter` e sobrescrever esses métodos, você pode fornecer a configuração personalizada para a segurança do seu aplicativo, adaptando-a 
às suas necessidades específicas.


Essa classe é amplamente utilizada para configurar a segurança em aplicativos web Spring, permitindo a definição de políticas de autenticação e autorização de forma flexível e 
adaptável.

------------- // ------------- 
 
A anotação `@Configuration` é uma anotação fornecida pelo Spring Framework que indica que uma classe é uma classe de configuração. Essa anotação é usada para configurar e definir 
beans no contexto de aplicativos Spring.

Quando uma classe é anotada com `@Configuration`, ela é tratada como uma fonte de definições de configuração para o aplicativo. Isso significa que a classe contém métodos que são 
responsáveis por criar e configurar beans do Spring, que são objetos gerenciados pelo contêiner do Spring.

Os principais pontos a serem observados sobre a anotação `@Configuration` são:

1. Identificação de Classe de Configuração: A anotação `@Configuration` informa ao Spring que a classe é uma classe de configuração. Isso significa que ela contém definições e 
                                            configurações para o aplicativo.

2. Métodos Anotados com `@Bean`: Dentro de uma classe anotada com `@Configuration`, você pode ter métodos anotados com `@Bean`. Esses métodos são responsáveis por criar e 
                                 configurar os beans do Spring. O retorno desses métodos é o objeto que será gerenciado pelo contêiner do Spring.

3. Criação de Beans: Os métodos anotados com `@Bean` retornam objetos que são gerenciados pelo contêiner do Spring. Esses objetos podem ser instâncias de classes próprias, 
                     componentes de terceiros ou até mesmo objetos criados manualmente.

4. Injeção de Dependências: A anotação `@Configuration` trabalha em conjunto com outras anotações do Spring, como `@Autowired`, permitindo a injeção de dependências nos beans 
                            criados. Isso facilita a configuração e a conexão de diferentes componentes do aplicativo.

Em resumo, a anotação `@Configuration` é usada para marcar uma classe como uma classe de configuração no contexto do Spring. Essa anotação permite a definição e configuração de 
beans do Spring por meio de métodos anotados com `@Bean`, permitindo a criação de objetos gerenciados pelo contêiner do Spring e a configuração de dependências entre eles.

------------- // ------------- 

A anotação `@EnableWebSecurity` é uma anotação fornecida pelo Spring Security que habilita a segurança web no aplicativo. Essa anotação é usada em conjunto com a classe de 
configuração que estende `WebSecurityConfigurerAdapter` para configurar as medidas de segurança no aplicativo.

Quando você adiciona a anotação `@EnableWebSecurity` em sua classe de configuração, você está ativando a segurança web fornecida pelo Spring Security. Isso permite que você 
defina regras de segurança, configure autenticação e autorização, e aplique outras medidas de proteção em seu aplicativo web.

A anotação `@EnableWebSecurity` habilita o módulo de segurança web do Spring Security e, por padrão, cria uma instância do filtro `springSecurityFilterChain`. Esse filtro é 
responsável por interceptar e processar as requisições HTTP, aplicando as configurações de segurança definidas na classe de configuração.

Além disso, a anotação `@EnableWebSecurity` também permite a personalização da configuração de segurança através da sobrescrita do método `configure` na classe que estende 
`WebSecurityConfigurerAdapter`. Esse método permite que você defina as regras de autenticação, autorização e outras configurações de segurança específicas para o seu aplicativo.

Em resumo, a anotação `@EnableWebSecurity` é usada para habilitar a segurança web no aplicativo Spring utilizando o Spring Security. Ela permite que você configure as medidas de 
segurança, como autenticação e autorização, e personalize as configurações de segurança do aplicativo web.

------------- // ------------- 

O script representa um método sobrescrito chamado `configure` na classe que estende `WebSecurityConfigurerAdapter`. Esse método é usado para configurar as regras de segurança para 
o aplicativo web.

Explicação de cada linha do script:

1. `@Override`: Essa anotação indica que o método está sobrescrevendo um método da classe pai.

2. `protected void configure(HttpSecurity http) throws Exception`: Este é o cabeçalho do método `configure` que recebe um objeto `HttpSecurity`. O `HttpSecurity` é usado para 
                                                                   configurar as regras de segurança do aplicativo.

3. `http.csrf().disable()`: Desabilita a proteção CSRF (Cross-Site Request Forgery), que é uma medida de segurança para prevenir ataques de falsificação de solicitação entre 
                            sites. Neste caso, a proteção CSRF está sendo desabilitada.

4. `authorizeRequests()`: Inicia a configuração das regras de autorização.

5. `antMatchers(HttpMethod.GET, "/").permitAll()`: Permite que todas as solicitações GET para a raiz ("/") sejam acessadas sem autenticação. Isso significa que a página inicial 
                                                   do aplicativo estará acessível para todos.

6. `anyRequest().authenticated()`: Requer autenticação para qualquer outra solicitação que não tenha sido configurada anteriormente. Isso significa que, para todas as outras 
                                   solicitações que não são GET para a raiz, é necessária autenticação.

7. `formLogin().permitAll()`: Permite que todas as solicitações de login (formulário de login) sejam acessadas sem autenticação. Isso significa que a página de login estará 
                              acessível para todos.

8. `logout().logoutRequestMatcher(new AntPathRequestMatcher("/logout"))`: Configura o logout para a URL "/logout". Quando uma solicitação GET ou POST é feita para essa URL, o 
                                                                          usuário será desconectado e redirecionado para a página de login.

Em resumo, esse método de configuração define as regras de segurança para o aplicativo web. Ele desabilita a proteção CSRF, permite o acesso sem autenticação à página inicial e 
ao formulário de login, requer autenticação para todas as outras solicitações e configura a URL de logout.

------------- // -------------

Esse script representa um método sobrescrito chamado `configure` na classe que estende `WebSecurityConfigurerAdapter`. Esse método é usado para configurar o gerenciador de 
autenticação para o aplicativo web.

Explicação de cada linha do script:

1. `@Override`: Essa anotação indica que o método está sobrescrevendo um método da classe pai.

2. `protected void configure(AuthenticationManagerBuilder auth) throws Exception`: Este é o cabeçalho do método `configure` que recebe um objeto `AuthenticationManagerBuilder`. 
                                                                                   O `AuthenticationManagerBuilder` é usado para configurar o gerenciador de autenticação do aplicativo.

3. `auth.inMemoryAuthentication()`: Configura a autenticação em memória, o que significa que as informações de autenticação serão armazenadas em memória.

4. `passwordEncoder(NoOpPasswordEncoder.getInstance())`: Configura o codificador de senha a ser usado para autenticação em memória. Neste caso, está sendo utilizado 
                                                         `NoOpPasswordEncoder`, que não faz nenhuma codificação ou hash na senha. No entanto, o uso de `NoOpPasswordEncoder` não 
                                                         é recomendado em ambientes de produção, pois as senhas ficam expostas em texto simples. É preferível utilizar um 
                                                         codificador seguro, como BCryptPasswordEncoder.

5. `withUser("admin")`: Define um usuário com o nome "admin".

6. `password("123")`: Define a senha do usuário como "123".

7. `roles("ADMIN")`: Atribui a função (role) "ADMIN" ao usuário. Essa função pode ser usada para restringir o acesso a determinadas partes do aplicativo com base nas permissões 
                     associadas a essa função.

Em resumo, esse método de configuração define um gerenciador de autenticação em memória para o aplicativo web. Ele cria um usuário com nome "admin", senha "123" e atribui a 
função "ADMIN" a esse usuário. Esse usuário pode ser usado para autenticação durante o processo de login do aplicativo. É importante observar que esse exemplo de autenticação em 
memória é apenas para fins de demonstração e não é adequado para um ambiente de produção, onde é recomendado o uso de um sistema de autenticação mais robusto, como autenticação 
baseada em banco de dados ou integração com provedores de autenticação externos.

------------- // -------------

Esse script representa um método chamado `configure` na classe que estende `WebSecurityConfigurerAdapter`. Esse método é usado para 
configurar a segurança para recursos estáticos específicos que estão fora do escopo da segurança do Spring Security.

Explicação do script:

1. `public void configure(WebSecurity web) throws Exception`: Este é o cabeçalho do método `configure` que recebe um objeto `WebSecurity`. O `WebSecurity` é usado para configurar 
                                                              a segurança para recursos estáticos.

2. `web.ignoring()`: Indica que determinados recursos estáticos devem ser ignorados pela configuração de segurança do Spring Security.

3. `antMatchers("/materialize/**")`: Especifica os padrões de URL que correspondem aos recursos estáticos que devem ser ignorados. Nesse caso, os recursos que correspondem a 
                                     qualquer URL que comece com "/materialize/" serão ignorados.

Ao usar `web.ignoring().antMatchers(...)`, você está instruindo o Spring Security a ignorar a aplicação de regras de segurança para os recursos estáticos especificados. Isso 
significa que qualquer solicitação para os recursos estáticos correspondentes não será interceptada pelo Spring Security e não exigirá autenticação ou autorização.

No exemplo fornecido, os recursos estáticos sob o diretório "/materialize" estão sendo ignorados pela configuração de segurança. Isso pode ser útil quando você tem bibliotecas 
ou arquivos CSS, JavaScript ou imagens que não precisam ser protegidos pela segurança do Spring Security.

É importante observar que, ao configurar a segurança para recursos estáticos, você deve garantir que esses recursos não contenham informações confidenciais ou restritas, pois 
eles não serão protegidos pelo Spring Security.

---------------------------------------------------------------------------------- // -------------------------------------------------------------------------------------------
      < Estrutura de classes Spring Security com Banco de Dados >

              1
         ____________                    __________________
        | UserDetails |                  | UserRepository |
        |_____________|                  |________________|
               ^                               ^  |
               |                               |  |
               |                               |  |
               |                               |  v
         _________                        _____________________
        | Usuario |                       | UserDetailsService |
        |[tabela] | --------------------  |____________________|
        |_________|          |
                         Web Security
 


O `UserDetails` é uma interface do Spring Security que define os detalhes de um usuário autenticado no sistema. Essa interface fornece informações necessárias para o Spring 
Security realizar a autenticação e autorização.

A interface `UserDetails` define os seguintes métodos que devem ser implementados:

- `Collection<? extends GrantedAuthority> getAuthorities()`: Retorna uma coleção de objetos `GrantedAuthority`, que representam as permissões ou papéis (roles) do usuário autenticado.

- `String getPassword()`: Retorna a senha do usuário. É importante notar que, por razões de segurança, o retorno desse método geralmente é a senha criptografada ou codificada de 
                          alguma forma.

- `String getUsername()`: Retorna o nome de usuário do usuário autenticado.

- `boolean isAccountNonExpired()`: Indica se a conta do usuário não está expirada.

- `boolean isAccountNonLocked()`: Indica se a conta do usuário não está bloqueada.

- `boolean isCredentialsNonExpired()`: Indica se as credenciais do usuário (por exemplo, senha) não estão expiradas.

- `boolean isEnabled()`: Indica se a conta do usuário está habilitada.

2. **Implementação da interface UserDetails:**

Normalmente, você implementa a interface `UserDetails` em uma classe de usuário personalizada que representa os detalhes de um usuário autenticado em seu sistema. Essa classe 
geralmente contém informações como nome de usuário, senha, permissões, papéis (roles) e outros atributos relacionados ao usuário.

3. **Utilização do UserDetails no processo de autenticação e autorização:**

Ao usar o Spring Security, os objetos `UserDetails` são normalmente retornados pelo `UserDetailsService`, que é uma interface usada para carregar os detalhes do usuário a partir 
de uma origem de dados, como um banco de dados. O `UserDetailsService` é responsável por fornecer os detalhes do usuário com base em um nome de usuário fornecido durante o 
processo de autenticação.

Os detalhes do usuário fornecidos pelo `UserDetailsService` são então usados pelo Spring Security para autenticar o usuário e verificar as permissões e restrições de acesso.

Essa estrutura do `UserDetails` no Spring Security permite que você personalize o processo de autenticação e autorização, fornecendo informações específicas do usuário no 
contexto do seu sistema.

Lembre-se de que a implementação específica da interface `UserDetails` pode variar dependendo do seu sistema e da forma como você deseja armazenar e gerenciar os detalhes do 
usuário. É possível personalizar a implementação para se adequar às necessidades do seu aplicativo, como integração com um banco de dados de usuários ou um provedor de 
autenticação externo.

------------- // -------------

A interface CrudRepository possui métodos padrão para realizar as operações básicas de CRUD, como salvar (save), atualizar (save), excluir (delete), buscar por ID (findById) e 
buscar todos (findAll).

Ao estender a interface CrudRepository com os tipos apropriados, você herda esses métodos e pode utilizá-los para interagir com o banco de dados de forma fácil e conveniente, 
sem a necessidade de escrever código repetitivo.

A interface UsuarioRepository estende a CrudRepository com os tipos Usuario (a entidade que representa os dados do usuário) e Long (o tipo do ID da entidade).

Com isso, a interface UsuarioRepository herda automaticamente os métodos básicos de CRUD, permitindo que você execute operações de persistência, como salvar, atualizar, excluir 
e buscar usuários no banco de dados, sem a necessidade de implementar esses métodos manualmente.

Além dos métodos padrão, você também pode adicionar métodos personalizados na interface UsuarioRepository para realizar consultas mais específicas e personalizadas no banco de 
dados, utilizando a sintaxe do Spring Data JPA ou outros recursos fornecidos pelo Spring Data.

Essa abordagem do CrudRepository do Spring Data simplifica o desenvolvimento de operações de persistência básicas, tornando mais fácil e produtivo o trabalho com o banco de dados 
em aplicativos Spring.

------------- // -------------

A classe UserDetailsService é uma interface do Spring Security que define um contrato para carregar os detalhes de um usuário a partir de uma origem de dados, como um banco de dados, para fins de autenticação e autorização.

Aqui estão alguns pontos importantes sobre a classe UserDetailsService do Spring Security:

Objetivo do UserDetailsService:
O objetivo principal do UserDetailsService é carregar os detalhes do usuário com base em um nome de usuário fornecido durante o processo de autenticação. Esses detalhes são então 
usados pelo Spring Security para autenticar o usuário e verificar as permissões e restrições de acesso.

Método loadUserByUsername:
A interface UserDetailsService define um único método chamado loadUserByUsername. Esse método é responsável por carregar os detalhes do usuário com base em um nome de usuário.

O método recebe um parâmetro username que representa o nome de usuário do usuário a ser carregado. Ele retorna um objeto UserDetails que contém os detalhes do usuário, como nome 
de usuário, senha e permissões.

Se o usuário não for encontrado, o método loadUserByUsername deve lançar uma exceção UsernameNotFoundException para indicar que o usuário não existe.

Implementação do UserDetailsService:
Para utilizar a classe UserDetailsService, você precisa criar uma classe que implemente essa interface e fornecer uma implementação do método loadUserByUsername que carregue os 
detalhes do usuário da sua origem de dados, como um banco de dados.

------------- // ---------------

A fins de Estudo:
A anotação @Autowired é uma anotação do Spring Framework que é usada para realizar a injeção de dependência automaticamente em classes e componentes.

A injeção de dependência é um padrão de projeto amplamente utilizado que permite a criação de componentes independentes e facilita a manutenção, o teste e a reutilização de código. 
Com a injeção de dependência, as dependências de um objeto são fornecidas por um mecanismo externo, em vez de serem criadas ou gerenciadas internamente pelo objeto.

Ao usar a anotação @Autowired, você está indicando ao Spring que deseja que ele resolva e injete automaticamente as dependências para você.

Existem várias maneiras de usar a anotação @Autowired:
  1. Injeção de Dependência em Construtor;
  2. Injeção de Dependência em Método Setter;
  3. Injeção de Dependência em Atributo;

Lembre-se de que para que a injeção de dependência ocorra, é necessário que a classe a ser injetada (dependência) seja gerenciada pelo Spring, ou seja, também precisa estar 
anotada com @Component, @Service, @Repository ou outras anotações específicas do Spring.

Em resumo, a anotação @Autowired é usada para realizar a injeção de dependência automaticamente pelo Spring Framework, simplificando o processo de gerenciamento de dependências 
em um aplicativo Spring.

------------- // ---------------

Para testar vamos fazer um insert no usuário no banco de dados:
INSERT INTO public.usuario(
            id, login, senha)
    VALUES (1, 'admin', '$2a$10$t73SPdIn7BadIcSACXLsp.nHwwtTXZnY/4bRZFZCy5.kwZQo7CiZW');
