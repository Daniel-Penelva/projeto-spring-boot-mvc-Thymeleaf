   < ARQUITETURA MVC - FUNCIONAMENTO > 
                                  
                                                                                                   |-----------------------------------------------
 Tela/ Cliente/ Sistema                                                                            |         JAVA/ SPRING MVC/ SERVLET            |
    _______                                                                                        |                                              |
   |       |                                                                                       |                                              |
   |       |                requisição /POST/GET                                                   |   CONTROLLER                BANCO DE DADOS   |
   |       | ------------------------------------------------------------------------------------->| |------------|              |------------|   |
   |       |                                                                                       | | validações |              |    dados   |   |
   |       | RESPOSTA compilada com o HTML para o navegador interpretar                            | |            |              |            |   |
   |_______| <-------------------------------------------------------------------------------------| |____________|              |____________|   |
                                                                                                   |                                              |
   Front-End                                                                                       |    ^    |                      ^      |      |
    (HTML)                                                                                         |    |    |                      |      |      |
  (Javascript)                                                                                     |    |    v                      |      v      |
                                                                                                   |                                              |
                                                                                                   |   SERVICE                    DAO/REPOSITORY  |
                                                                                                   | |----------|                 |-----------|   |
                                                                                                   | | Regra de | --------------> | SQL/JPA   |   |
                                                                                                   | | negócio  | <-------------- |           |   |
                                                                                                   | |__________|                 |___________|   |
                                                                                                   |______________________________________________|

A arquitetura MVC (Model-View-Controller) é um padrão de arquitetura de software amplamente utilizado para o desenvolvimento de aplicativos. Ele separa a lógica de 
negócios, a apresentação dos dados e a interação com o usuário em três componentes distintos: Model, View e Controller. Cada componente possui responsabilidades 
específicas e se comunica com os outros componentes de forma estruturada. Vamos entender como cada componente funciona:

1. Model:
O Model representa a camada de dados e lógica de negócios. Ele encapsula o estado e o comportamento dos dados da aplicação. Essa camada é responsável por acessar e 
manipular os dados, bem como aplicar as regras de negócio. O Model geralmente consiste em classes como entidades, serviços, repositórios, APIs, etc.

2. View:
A View é responsável pela apresentação dos dados ao usuário. Ela exibe a interface do usuário, como páginas HTML, telas, formulários, gráficos, entre outros elementos 
visuais. A View recebe dados do Model para exibi-los e também envia informações do usuário para o Controller. Geralmente, as Views são implementadas usando tecnologias 
como HTML, CSS, JavaScript, JSP, Thymeleaf, entre outras.

3. Controller:
O Controller é responsável por receber as requisições do usuário, processá-las e coordenar as ações apropriadas. Ele atua como intermediário entre a View e o Model. 
O Controller é responsável por receber os dados da View, interagir com o Model para executar ações necessárias, como buscar dados, atualizar informações, executar 
lógica de negócio, etc., e então retornar os resultados para a View. Normalmente, os Controllers são implementados como classes ou métodos em frameworks web, como 
Spring MVC, ASP.NET MVC, Django, entre outros.

No contexto da arquitetura MVC, o Service (ou Service Layer) é responsável por abrigar a lógica de negócio da aplicação. Ele atua como uma camada intermediária entre 
o Controller e o Model, encapsulando as regras e operações complexas relacionadas ao domínio do problema. O Service é uma prática comum em muitas implementações de MVC
e tem como objetivo principal separar a lógica de negócio do Controller e do Model, mantendo assim a responsabilidade de cada camada de forma clara e modular.

No contexto da arquitetura MVC, o DAO (Data Access Object) ou Repository é responsável por encapsular a interação com o banco de dados e fornecer métodos para realizar 
operações de persistência e recuperação de dados. O DAO/Repository atua como uma camada de abstração entre o Model e o banco de dados, permitindo que o restante da 
aplicação trabalhe com objetos do Model sem se preocupar com detalhes específicos de acesso aos dados. Em resumo, o DAO/Repository na estrutura MVC é responsável por 
encapsular a lógica de acesso aos dados do banco de dados, fornecendo métodos para realizar operações de persistência e recuperação de dados. Ele abstrai os detalhes 
de acesso ao banco de dados, permite consultas customizadas e promove a testabilidade das operações de dados.

O fluxo básico de funcionamento da arquitetura MVC é o seguinte:

1. O usuário interage com a View, como preenchendo um formulário ou clicando em um botão.
2. A View captura as interações do usuário e envia uma requisição para o Controller correspondente.
3. O Controller recebe a requisição, processa-a e interage com o Model, se necessário, para executar as ações apropriadas.
4. O Model executa as operações de manipulação de dados e lógica de negócio necessárias.
5. O Controller recebe os resultados do Model e seleciona a View adequada para renderizar os dados.
6. A View recebe os dados do Controller e os apresenta ao usuário de forma adequada.
7. O usuário visualiza os resultados na View e, se necessário, inicia uma nova interação.

Essa separação de responsabilidades facilita a manutenção, a reutilização de código e o desenvolvimento colaborativo, uma vez que cada componente possui uma função 
claramente definida. Além disso, a arquitetura MVC permite uma maior flexibilidade, pois é possível alterar a View ou o Model independentemente um do outro, desde que 
a interface entre eles seja mantida.

Vale ressaltar que existem variações e adaptações do padrão MVC, como o MVVM (Model-View-ViewModel) e o MVP (Model-View-Presenter), que incorporam diferentes abordagens 
para atender a necessidades específicas de diferentes frameworks e tecnologias. No entanto, a ideia fundamental de separação de responsabilidades entre Model, View e 
Controller permanece como base em várias arquiteturas de software.

--------------------------------------------------------------------------------------------------- // --------------------------------------------------------------------------

Bom Saber:

A propriedade "spring.jpa.properties.hibernate.temp.use_jdbc_metadata_defaults" é uma configuração específica do Hibernate, um framework de mapeamento objeto-relacional para Java, 
quando usado em conjunto com o Spring Framework.

Essa propriedade determina se o Hibernate deve usar os metadados padrão do JDBC (Java Database Connectivity) ao criar tabelas temporárias durante a execução de consultas. Quando 
definida como "false", o Hibernate irá desabilitar o uso dos metadados padrão do JDBC e, em vez disso, irá usar seus próprios metadados para a criação das tabelas temporárias.

Essa configuração pode ser útil em certos casos em que o comportamento padrão do Hibernate com relação às tabelas temporárias não atende aos requisitos específicos do aplicativo. 
Ao desabilitar o uso dos metadados padrão do JDBC, você pode ter um controle mais preciso sobre a criação e configuração dessas tabelas temporárias.

É importante destacar que essa é apenas uma das várias propriedades de configuração disponíveis no Hibernate e no Spring Framework, e seu efeito exato dependerá do contexto em 
que está sendo utilizada, assim como das outras configurações do aplicativo. Recomenda-se consultar a documentação oficial do Hibernate e do Spring Framework para obter informações 
mais detalhadas sobre o uso dessa propriedade e outras configurações relacionadas.

------------- // -------------

A propriedade "spring.jpa.properties.hibernate.dialect" é utilizada para configurar o dialeto (dialect) do Hibernate ao trabalhar com um banco de dados específico. Neste caso em 
particular, o valor definido para a propriedade é "org.hibernate.dialect.PostgreSQLDialect", indicando que o Hibernate deve utilizar o dialeto do PostgreSQL.

O dialeto do Hibernate é responsável por fornecer as instruções SQL específicas do banco de dados que estão sendo utilizadas. Cada banco de dados possui suas próprias particularidades 
e diferenças na sintaxe e recursos SQL. Portanto, é necessário configurar corretamente o dialeto do Hibernate para que ele possa gerar as consultas SQL adequadas e compatíveis 
com o banco de dados em uso.

Ao definir "org.hibernate.dialect.PostgreSQLDialect" como o valor dessa propriedade, o Hibernate irá gerar as consultas SQL específicas para o PostgreSQL. O dialeto do PostgreSQL 
é otimizado para trabalhar com esse banco de dados em particular, aproveitando os recursos e as funcionalidades específicas oferecidas pelo PostgreSQL.

É importante observar que o Hibernate oferece uma variedade de dialetos para diferentes bancos de dados, e a escolha correta do dialeto a ser usado depende do banco de dados que 
está sendo utilizado em sua aplicação. Se você estiver usando um banco de dados diferente do PostgreSQL, será necessário fornecer o dialeto apropriado correspondente ao seu banco 
de dados específico.

------------- // -------------

A anotação `@ComponentScan` é uma anotação do Spring Framework que é usada para especificar os pacotes base a serem verificados em busca de componentes gerenciados pelo Spring, 
como classes anotadas com `@Component`, `@Service`, `@Repository` ou `@Controller`.

A anotação `@ComponentScan` é usada em conjunto com a anotação `@Configuration` ou `@SpringBootApplication` para definir a configuração do contexto do Spring e permitir que o 
Spring encontre automaticamente e registre os componentes dentro dos pacotes especificados.

No exemplo dado, a anotação `@ComponentScan(basePackages = {"projeto.*"})` está configurada para escanear os pacotes que possuem o prefixo "projeto.". Isso significa que o Spring 
irá percorrer esses pacotes em busca de classes anotadas com `@Component`, `@Service`, `@Repository` ou `@Controller` para serem registradas como beans gerenciados pelo Spring.

Essa anotação é útil quando você possui componentes personalizados que precisam ser reconhecidos e gerenciados pelo Spring, permitindo que você aproveite a injeção de dependência, 
a configuração automática e outros recursos do Spring Framework.

Você pode ajustar os pacotes especificados no array `basePackages` para corresponder aos pacotes relevantes do seu projeto. Além disso, você também pode usar outras opções, como 
`basePackageClasses` para especificar as classes base ou `value` como um alias para `basePackages`.

Em resumo, a anotação `@ComponentScan` permite ao Spring encontrar automaticamente componentes em pacotes específicos e registrá-los como beans gerenciados pelo Spring. Isso 
facilita o desenvolvimento e configuração de aplicativos Spring, pois você não precisa registrar manualmente cada componente individualmente.

------------- // -------------

A anotação `@Repository` é uma anotação do Spring Framework que é usada para indicar que uma classe é responsável por acessar e manipular dados persistentes, geralmente em um 
banco de dados. 

A anotação `@Repository` é uma especialização da anotação `@Component`, o que significa que uma classe anotada com `@Repository` será tratada como um componente pelo Spring e 
será elegível para injeção de dependência e outras funcionalidades fornecidas pelo Spring.

O propósito principal da anotação `@Repository` é fornecer um meio para categorizar e identificar classes que atuam como repositórios de dados. Esses repositórios são responsáveis 
por fornecer uma abstração para o acesso a dados persistentes, encapsulando detalhes específicos do armazenamento de dados, como consultas SQL ou interações com o banco de dados.

Ao usar a anotação `@Repository`, você permite que o Spring realize a injeção de dependência automaticamente em outras classes que dependem desse repositório. Além disso, a 
anotação `@Repository` também oferece recursos adicionais, como a tradução automática de exceções específicas do banco de dados para exceções de persistência do Spring.

Embora o uso da anotação `@Repository` seja opcional, é uma prática comum aplicá-la a classes que atuam como repositórios de dados, pois ela ajuda na organização e semântica do 
código, além de fornecer recursos adicionais fornecidos pelo Spring.

É importante observar que a anotação `@Repository` faz parte do contexto do Spring Data, que é uma subestrutura do Spring Framework que fornece abstrações e recursos adicionais 
para acesso a dados. Portanto, seu uso é frequentemente associado ao Spring Data JPA, Spring Data JDBC, Spring Data MongoDB e outras implementações do Spring Data.

Em resumo, a anotação `@Repository` é usada para marcar uma classe como um repositório de dados, permitindo que o Spring a gerencie como um componente e forneça recursos 
adicionais para acesso a dados persistentes.

------------- // -------------

A anotação `@Transactional` é uma anotação do Spring Framework que é usada para indicar que um método ou classe deve ser executado dentro de um contexto transacional. 

Quando um método é anotado com `@Transactional`, o Spring cuida da criação e gerenciamento de uma transação para esse método. Transações são utilizadas para garantir a atomicidade, 
consistência, isolamento e durabilidade (ACID) das operações em um banco de dados ou outro recurso transacional.

A anotação `@Transactional` pode ser aplicada a um método específico ou a toda uma classe. Quando aplicada a um método específico, somente esse método será executado em uma 
transação. Se aplicada a uma classe, todos os métodos dentro dessa classe serão executados em uma transação.

Ao utilizar a anotação `@Transactional`, você pode obter vários benefícios:

1. Gerenciamento automático de transações: O Spring cuida da criação, commit e rollback de transações, tornando o código mais simples e livre de preocupações com o controle manual 
   de transações.

2. Suporte a várias estratégias de transação: O Spring suporta várias estratégias de transação, como transações baseadas em anotações, transações programáticas e transações 
   declarativas baseadas em XML. Você pode configurar a estratégia de transação adequada para suas necessidades.

3. Controle de isolamento e propagação da transação: A anotação `@Transactional` permite que você especifique o nível de isolamento da transação e a propagação para outros métodos 
   chamados. Isso garante a consistência e o comportamento esperado das transações em diferentes cenários.

4. Tratamento de exceções e rollback: O Spring trata exceções lançadas dentro de um método transacional e realiza o rollback da transação em caso de exceção não tratada. Isso 
   garante que as operações sejam revertidas adequadamente em caso de falhas.

É importante ressaltar que a anotação `@Transactional` deve ser usada com cuidado e em conjunto com um mecanismo de gerenciamento de transações adequado, como o Spring 
Transaction Management. Além disso, é importante considerar os detalhes de configuração e a configuração do ambiente para garantir o comportamento desejado das transações.

Em resumo, a anotação `@Transactional` é usada para marcar métodos ou classes que devem ser executados dentro de um contexto transacional, permitindo que o Spring gerencie 
automaticamente as transações e forneça recursos avançados, como controle de isolamento, propagação, tratamento de exceções e rollback.

------------- // -------------

A classe `CrudRepository<T, ID>` faz parte do Spring Data e é uma interface genérica fornecida pelo Spring Framework para facilitar a criação de repositórios de acesso a dados.

Vamos analisar cada um dos parâmetros utilizados na classe `CrudRepository<Pessoa, Long>`:

1. `T` é o tipo de entidade (modelo de dados) com o qual o repositório está lidando. No exemplo dado, `Pessoa` é o tipo da entidade que o repositório manipulará. Você substituirá 
   `Pessoa` pelo nome da sua entidade.

2. `ID` é o tipo do identificador único da entidade. O `ID` pode ser um tipo primitivo, como `Long`, `Integer`, `String`, ou um tipo personalizado. No exemplo dado, o identificador 
   único da entidade `Pessoa` é do tipo `Long`. Mais uma vez, você substituirá `Long` pelo tipo adequado do identificador da sua entidade.

A classe `CrudRepository` fornece um conjunto de métodos prontos para uso para realizar operações CRUD (Create, Read, Update, Delete) no banco de dados. Alguns dos métodos mais 
comuns fornecidos pela `CrudRepository` incluem:

- 'save(entity)': Salva ou atualiza uma entidade no banco de dados.
- 'findById(id)': Recupera uma entidade pelo seu identificador único.
- 'findAll()': Recupera todas as entidades do tipo especificado.
- 'delete(entity)': Exclui uma entidade do banco de dados.
- 'count()': Retorna o número total de entidades no repositório.

Esses métodos e outros estão disponíveis na classe `CrudRepository`, permitindo que você execute operações básicas de CRUD sem a necessidade de escrever código repetitivo. No 
entanto, a `CrudRepository` é uma interface genérica e precisa ser estendida por uma interface personalizada ou uma classe concreta para ser utilizada.

Ao estender a `CrudRepository`, você pode adicionar métodos personalizados para atender às necessidades específicas do seu domínio, se necessário.

Por exemplo, se você estender a `CrudRepository<Pessoa, Long>` com uma interface chamada `PessoaRepository`, você poderá utilizar métodos herdados, como `findById`, `save`, 
`findAll`, etc., além de adicionar métodos personalizados, como `findByNome` ou `findByEmail`.

Em resumo, a classe `CrudRepository` é uma interface genérica do Spring Data que fornece operações básicas de CRUD para acesso a dados. Você pode estender essa interface e 
personalizá-la para manipular entidades específicas do seu domínio no banco de dados.

------------- // -------------

A anotação `@EnableJpaRepositories` é uma anotação do Spring Framework que é usada para habilitar os recursos de repositórios JPA (Java Persistence API) fornecidos pelo Spring 
Data JPA.

Essa anotação é tipicamente usada em uma classe de configuração do Spring, geralmente uma classe anotada com `@Configuration` ou uma classe de inicialização do aplicativo anotada 
com `@SpringBootApplication`.

Ao utilizar a anotação `@EnableJpaRepositories`, você está ativando a funcionalidade de repositórios JPA do Spring Data para o projeto. A anotação permite que você defina as 
configurações para os repositórios JPA, como a localização dos repositórios e outras opções de configuração.

A opção `basePackages` é usada para especificar o pacote (ou pacotes) onde os repositórios JPA estão localizados. No exemplo dado, `projeto.springboot.repository` é o pacote base 
onde os repositórios JPA estão localizados. Isso indica ao Spring Data JPA onde procurar por interfaces de repositório para implementação automática.

Ao definir o pacote base através da opção `basePackages`, o Spring Data JPA irá escanear esse pacote e seus subpacotes em busca de interfaces de repositório anotadas com 
`@Repository` ou outras anotações específicas do Spring Data JPA.

Uma vez que as interfaces de repositório são encontradas, o Spring Data JPA irá gerar automaticamente a implementação dessas interfaces em tempo de execução, fornecendo assim a 
funcionalidade de acesso a dados para as entidades correspondentes.

É importante mencionar que a anotação `@EnableJpaRepositories` também oferece outras opções de configuração, como `entityManagerFactoryRef`, `transactionManagerRef` e 
`repositoryImplementationPostfix`, que permitem personalizar ainda mais o comportamento dos repositórios JPA.

Em resumo, a anotação `@EnableJpaRepositories` é usada para habilitar a funcionalidade de repositórios JPA do Spring Data. Através dessa anotação, você pode especificar o pacote 
base onde os repositórios JPA estão localizados, permitindo que o Spring Data JPA os encontre, gere as implementações automaticamente e forneça acesso a dados para suas entidades.


------------- // -------------

A anotação `@EnableTransactionManagement` é uma anotação do Spring Framework que é usada para habilitar o suporte a transações em um aplicativo Spring.

Ao utilizar a anotação `@EnableTransactionManagement`, você está ativando o suporte a transações do Spring Framework, permitindo que você utilize transações declarativas no seu 
código.

Essa anotação é tipicamente usada em uma classe de configuração do Spring, geralmente uma classe anotada com `@Configuration` ou uma classe de inicialização do aplicativo anotada 
com `@SpringBootApplication`.

Ao habilitar o suporte a transações com `@EnableTransactionManagement`, você pode usar anotações como `@Transactional` em métodos de negócio ou serviços para indicar que eles 
devem ser executados dentro de uma transação.

A anotação `@Transactional` é responsável por iniciar, gerenciar e finalizar transações automaticamente para os métodos anotados. Quando um método anotado com `@Transactional` é 
chamado, uma transação é criada e o contexto da transação é definido. O Spring gerencia automaticamente o início e o fim da transação, além de lidar com o commit ou rollback da 
transação, dependendo do resultado do método.

Além disso, a anotação `@EnableTransactionManagement` também permite que você configure um gerenciador de transações personalizado, como um `PlatformTransactionManager`, para 
controlar o comportamento das transações.

Ao habilitar o suporte a transações, você pode alcançar os seguintes benefícios:

- Atomicidade: As transações são executadas como uma unidade indivisível, onde todas as operações são confirmadas ou revertidas em conjunto.
- Consistência: As transações garantem que os dados estejam em um estado consistente antes e após sua execução.
- Isolamento: As transações oferecem isolamento, permitindo que elas sejam executadas independentemente de outras transações em andamento.
- Durabilidade: As transações confirmadas são permanentes e não serão perdidas mesmo em caso de falhas ou reinicialização do sistema.

Em resumo, a anotação `@EnableTransactionManagement` é usada para habilitar o suporte a transações no Spring Framework. Isso permite que você utilize a anotação `@Transactional` 
para marcar métodos que devem ser executados em uma transação, facilitando o gerenciamento e a consistência dos dados no seu aplicativo.

------------- // -------------

<tr th:each="pessoa : ${pessoas}">

Essa propriedade "${pessoas}" vai vir do banco de dados.
A propriedade "pessoa" é o que vai ser mostrado na tela.

------------- // -------------


A classe ModelAndView é uma classe do Spring Framework que é usada para encapsular dados do modelo e informações da visualização em um objeto.

A classe ModelAndView é frequentemente utilizada em controladores do Spring MVC para fornecer dados ao modelo e especificar a visualização que será renderizada e retornada ao 
cliente.

A principal finalidade da classe ModelAndView é fornecer uma maneira conveniente de transmitir dados do controlador para a visualização, além de permitir que você especifique a 
visualização que deve ser renderizada.

Ao criar uma instância de ModelAndView, você pode definir o nome da visualização (o nome lógico da visualização configurada em seu aplicativo) e adicionar atributos ao modelo 
(dados que serão utilizados pela visualização para renderizar a resposta).

Ao retornar o objeto ModelAndView no método do controlador, o Spring MVC utilizará o nome da visualização para determinar a visualização que deve ser renderizada. Os atributos do modelo serão disponibilizados para a visualização para que ela possa usar os dados na renderização da resposta.

No exemplo, o Spring MVC procuraria pela visualização chamada "cadastro/cadastropessoa" e a renderizaria usando os dados fornecidos no modelo.

Além disso, a classe ModelAndView também oferece métodos para configurar outras propriedades, como status HTTP, cabeçalhos de resposta e redirecionamentos.

Em resumo, a classe ModelAndView é usada para encapsular dados do modelo e informações da visualização em um objeto no Spring Framework. Ela permite que você especifique o nome 
da visualização e adicione atributos ao modelo, facilitando a passagem de dados do controlador para a visualização.

